import { dig, digg, digs } from "diggerize";
import * as inflection from "inflection";
import qs from "qs";
import urlEncode from "./url-encode.js";
export default class ApiMakerRoutesNative {
    constructor({ getLocale }) {
        this.getLocale = getLocale;
        this.routeDefinitions = [];
        this.routeTranslationParts = {};
    }
    loadRouteDefinitions(routeDefinitions, routeDefinitionArgs) {
        for (const routeDefinition of digg(routeDefinitions, "routes")) {
            const { name, path } = digs(routeDefinition, "name", "path");
            const rawPathParts = path.split("/");
            const pathMethodName = `${inflection.camelize(name, true)}Path`;
            const urlMethodName = `${inflection.camelize(name, true)}Url`;
            if (routeDefinitionArgs && routeDefinitionArgs.localized) {
                const localizedRoutes = {};
                for (const locale in this.routeTranslationParts) {
                    let variableCount = 0;
                    const localizedPathParts = [
                        { type: "pathPart", name: "" },
                        { type: "pathPart", name: locale }
                    ];
                    for (let i = 1; i < rawPathParts.length; i++) {
                        const pathPart = rawPathParts[i];
                        const variableMatch = pathPart.match(/^:([A-z_]+)$/);
                        if (variableMatch) {
                            localizedPathParts.push({ type: "variable", count: variableCount++ });
                        }
                        else if (pathPart) {
                            const name = this.i18n.t(`routes.${pathPart}`, null, { default: pathPart, locale });
                            localizedPathParts.push({ type: "pathPart", name });
                        }
                    }
                    localizedRoutes[locale] = localizedPathParts;
                }
                this[pathMethodName] = (...args) => this.translateRoute({ args, localizedRoutes });
                this[urlMethodName] = (...args) => this.translateRoute({ args, localizedRoutes, url: true });
            }
            else {
                let variableCount = 0;
                const pathParts = rawPathParts.map((pathPart) => {
                    const variableMatch = pathPart.match(/^:([A-z_]+)$/);
                    if (variableMatch) {
                        return { type: "variable", count: variableCount };
                    }
                    else {
                        return { type: "pathPart", name: pathPart };
                    }
                });
                this[pathMethodName] = (...args) => this.translateRoute({ args, pathParts });
                this[urlMethodName] = (...args) => this.translateRoute({ args, pathParts, url: true });
            }
        }
    }
    loadRouteTranslations(i18n) {
        this.i18n = i18n;
        const locales = digg(i18n, "locales");
        for (const locale in locales) {
            const routeTranslations = dig(locales, locale, "routes");
            if (!routeTranslations)
                continue;
            if (!(locale in this.routeTranslationParts))
                this.routeTranslationParts[locale] = {};
            for (const key in routeTranslations) {
                this.routeTranslationParts[locale][key] = routeTranslations[key];
            }
        }
    }
    translateRoute({ args, localizedRoutes, pathParts, url }) {
        let options;
        // Extract options from args if any
        const lastArg = args[args.length - 1];
        if (lastArg && typeof lastArg == "object") {
            options = args.pop();
        }
        else {
            options = {};
        }
        // Take locale from options if given or fall back to fallback
        const { locale, host, port, protocol, ...restOptions } = options;
        if (localizedRoutes) {
            // Put together route with variables and static translated parts (which were translated and cached previously)
            let translatedRoute = digg(localizedRoutes, locale || this.getLocale())
                .map((pathPart) => {
                if (pathPart.type == "pathPart") {
                    return pathPart.name;
                }
                else if (pathPart.type == "variable") {
                    // Args might not contain the right amount of variables, so dont change this to 'digg'
                    return dig(args, digg(pathPart, "count"));
                }
                else {
                    throw new Error(`Unhandled path part type: ${pathPart.type}`);
                }
            })
                .join("/");
            if (restOptions && Object.keys(restOptions).length > 0) {
                translatedRoute += `?${qs.stringify(restOptions, { encoder: urlEncode })}`;
            }
            if (url)
                return this.addHostToRoute({ host, port, protocol, translatedRoute });
            return translatedRoute;
        }
        else if (pathParts) {
            // Put together route with variables and static translated parts (which were translated and cached previously)
            let translatedRoute = pathParts
                .map((pathPart) => {
                if (pathPart.type == "pathPart") {
                    return pathPart.name;
                }
                else if (pathPart.type == "variable") {
                    return digg(args, digg(pathPart, "count"));
                }
                else {
                    throw new Error(`Unhandled path part type: ${pathPart.type}`);
                }
            })
                .join("/");
            if (restOptions && Object.keys(restOptions).length > 0) {
                translatedRoute += `?${qs.stringify(restOptions, { encoder: urlEncode })}`;
            }
            if (url)
                return this.addHostToRoute({ host, port, protocol, translatedRoute });
            return translatedRoute;
        }
        throw new Error("Unhandled state");
    }
    addHostToRoute({ host, port, protocol, translatedRoute }) {
        let fullUrl = "";
        const hostToUse = host || globalThis.location && globalThis.location.host;
        const portToUse = port || globalThis.location && globalThis.location.port;
        if (!hostToUse)
            throw new Error("Unable to detect host");
        if (protocol) {
            fullUrl += `${protocol}://`;
        }
        else if (globalThis.location && globalThis.location.protocol) {
            fullUrl += `${globalThis.location.protocol}//`;
        }
        else {
            fullUrl += "https://";
        }
        fullUrl += hostToUse;
        if (portToUse && ((protocol == "http" && portToUse != 80) || (protocol == "https" && port != 443))) {
            fullUrl += `:${portToUse}`;
        }
        fullUrl += translatedRoute;
        return fullUrl;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVzLW5hdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIvc3JjLyIsInNvdXJjZXMiOlsicm91dGVzLW5hdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsTUFBTSxXQUFXLENBQUE7QUFDekMsT0FBTyxLQUFLLFVBQVUsTUFBTSxZQUFZLENBQUE7QUFDeEMsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFBO0FBQ25CLE9BQU8sU0FBUyxNQUFNLGlCQUFpQixDQUFBO0FBRXZDLE1BQU0sQ0FBQyxPQUFPLE9BQU8sb0JBQW9CO0lBQ3ZDLFlBQWEsRUFBQyxTQUFTLEVBQUM7UUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUE7UUFDMUIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQTtRQUMxQixJQUFJLENBQUMscUJBQXFCLEdBQUcsRUFBRSxDQUFBO0lBQ2pDLENBQUM7SUFFRCxvQkFBb0IsQ0FBRSxnQkFBZ0IsRUFBRSxtQkFBbUI7UUFDekQsS0FBSyxNQUFNLGVBQWUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUMvRCxNQUFNLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBQyxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFBO1lBQzFELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDcEMsTUFBTSxjQUFjLEdBQUcsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFBO1lBQy9ELE1BQU0sYUFBYSxHQUFHLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQTtZQUU3RCxJQUFJLG1CQUFtQixJQUFJLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxD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QUksSUFBSSxVQUFVLENBQUMsUUFBUSxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFBO1FBQ3pFLE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxVQUFVLENBQUMsUUFBUSxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFBO1FBRXpFLElBQUksQ0FBQyxTQUFTO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFBO1FBRXhELElBQUksUUFBUSxFQUFFLENBQUM7WUFDYixPQUFPLElBQUksR0FBRyxRQUFRLEtBQUssQ0FBQTtRQUM3QixDQUFDO2FBQU0sSUFBSSxVQUFVLENBQUMsUUFBUSxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDL0QsT0FBTyxJQUFJLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxRQUFRLElBQUksQ0FBQTtRQUNoRCxDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sSUFBSSxVQUFVLENBQUE7UUFDdkIsQ0FBQztRQUVELE9BQU8sSUFBSSxTQUFTLENBQUE7UUFFcEIsSUFBSSxTQUFTLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLElBQUksU0FBUyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ25HLE9BQU8sSUFBSSxJQUFJLFNBQVMsRUFBRSxDQUFBO1FBQzVCLENBQUM7UUFFRCxPQUFPLElBQUksZUFBZSxDQUFBO1FBRTFCLE9BQU8sT0FBTyxDQUFBO0lBQ2hCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZGlnLCBkaWdnLCBkaWdzfSBmcm9tIFwiZGlnZ2VyaXplXCJcbmltcG9ydCAqIGFzIGluZmxlY3Rpb24gZnJvbSBcImluZmxlY3Rpb25cIlxuaW1wb3J0IHFzIGZyb20gXCJxc1wiXG5pbXBvcnQgdXJsRW5jb2RlIGZyb20gXCIuL3VybC1lbmNvZGUuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcGlNYWtlclJvdXRlc05hdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICh7Z2V0TG9jYWxlfSkge1xuICAgIHRoaXMuZ2V0TG9jYWxlID0gZ2V0TG9jYWxlXG4gICAgdGhpcy5yb3V0ZURlZmluaXRpb25zID0gW11cbiAgICB0aGlzLnJvdXRlVHJhbnNsYXRpb25QYXJ0cyA9IHt9XG4gIH1cblxuICBsb2FkUm91dGVEZWZpbml0aW9ucyAocm91dGVEZWZpbml0aW9ucywgcm91dGVEZWZpbml0aW9uQXJncykge1xuICAgIGZvciAoY29uc3Qgcm91dGVEZWZpbml0aW9uIG9mIGRpZ2cocm91dGVEZWZpbml0aW9ucywgXCJyb3V0ZXNcIikpIHtcbiAgICAgIGNvbnN0IHtuYW1lLCBwYXRofSA9IGRpZ3Mocm91dGVEZWZpbml0aW9uLCBcIm5hbWVcIiwgXCJwYXRoXCIpXG4gICAgICBjb25zdCByYXdQYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKVxuICAgICAgY29uc3QgcGF0aE1ldGhvZE5hbWUgPSBgJHtpbmZsZWN0aW9uLmNhbWVsaXplKG5hbWUsIHRydWUpfVBhdGhgXG4gICAgICBjb25zdCB1cmxNZXRob2ROYW1lID0gYCR7aW5mbGVjdGlvbi5jYW1lbGl6ZShuYW1lLCB0cnVlKX1VcmxgXG5cbiAgICAgIGlmIChyb3V0ZURlZmluaXRpb25BcmdzICYmIHJvdXRlRGVmaW5pdGlvbkFyZ3MubG9jYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsaXplZFJvdXRlcyA9IHt9XG5cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbGUgaW4gdGhpcy5yb3V0ZVRyYW5zbGF0aW9uUGFydHMpIHtcbiAgICAgICAgICBsZXQgdmFyaWFibGVDb3VudCA9IDBcblxuICAgICAgICAgIGNvbnN0IGxvY2FsaXplZFBhdGhQYXJ0cyA9IFtcbiAgICAgICAgICAgIHt0eXBlOiBcInBhdGhQYXJ0XCIsIG5hbWU6IFwiXCJ9LFxuICAgICAgICAgICAge3R5cGU6IFwicGF0aFBhcnRcIiwgbmFtZTogbG9jYWxlfVxuICAgICAgICAgIF1cblxuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmF3UGF0aFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydCA9IHJhd1BhdGhQYXJ0c1tpXVxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVNYXRjaCA9IHBhdGhQYXJ0Lm1hdGNoKC9eOihbQS16X10rKSQvKVxuXG4gICAgICAgICAgICBpZiAodmFyaWFibGVNYXRjaCkge1xuICAgICAgICAgICAgICBsb2NhbGl6ZWRQYXRoUGFydHMucHVzaCh7dHlwZTogXCJ2YXJpYWJsZVwiLCBjb3VudDogdmFyaWFibGVDb3VudCsrfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF0aFBhcnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuaTE4bi50KGByb3V0ZXMuJHtwYXRoUGFydH1gLCBudWxsLCB7ZGVmYXVsdDogcGF0aFBhcnQsIGxvY2FsZX0pXG5cbiAgICAgICAgICAgICAgbG9jYWxpemVkUGF0aFBhcnRzLnB1c2goe3R5cGU6IFwicGF0aFBhcnRcIiwgbmFtZX0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbG9jYWxpemVkUm91dGVzW2xvY2FsZV0gPSBsb2NhbGl6ZWRQYXRoUGFydHNcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbcGF0aE1ldGhvZE5hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMudHJhbnNsYXRlUm91dGUoe2FyZ3MsIGxvY2FsaXplZFJvdXRlc30pXG4gICAgICAgIHRoaXNbdXJsTWV0aG9kTmFtZV0gPSAoLi4uYXJncykgPT4gdGhpcy50cmFuc2xhdGVSb3V0ZSh7YXJncywgbG9jYWxpemVkUm91dGVzLCB1cmw6IHRydWV9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZhcmlhYmxlQ291bnQgPSAwXG5cbiAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcmF3UGF0aFBhcnRzLm1hcCgocGF0aFBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCB2YXJpYWJsZU1hdGNoID0gcGF0aFBhcnQubWF0Y2goL146KFtBLXpfXSspJC8pXG5cbiAgICAgICAgICBpZiAodmFyaWFibGVNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcInZhcmlhYmxlXCIsIGNvdW50OiB2YXJpYWJsZUNvdW50fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwicGF0aFBhcnRcIiwgbmFtZTogcGF0aFBhcnR9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXNbcGF0aE1ldGhvZE5hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMudHJhbnNsYXRlUm91dGUoe2FyZ3MsIHBhdGhQYXJ0c30pXG4gICAgICAgIHRoaXNbdXJsTWV0aG9kTmFtZV0gPSAoLi4uYXJncykgPT4gdGhpcy50cmFuc2xhdGVSb3V0ZSh7YXJncywgcGF0aFBhcnRzLCB1cmw6IHRydWV9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRSb3V0ZVRyYW5zbGF0aW9ucyAoaTE4bikge1xuICAgIHRoaXMuaTE4biA9IGkxOG5cbiAgICBjb25zdCBsb2NhbGVzID0gZGlnZyhpMThuLCBcImxvY2FsZXNcIilcblxuICAgIGZvciAoY29uc3QgbG9jYWxlIGluIGxvY2FsZXMpIHtcbiAgICAgIGNvbnN0IHJvdXRlVHJhbnNsYXRpb25zID0gZGlnKGxvY2FsZXMsIGxvY2FsZSwgXCJyb3V0ZXNcIilcblxuICAgICAgaWYgKCFyb3V0ZVRyYW5zbGF0aW9ucykgY29udGludWVcbiAgICAgIGlmICghKGxvY2FsZSBpbiB0aGlzLnJvdXRlVHJhbnNsYXRpb25QYXJ0cykpIHRoaXMucm91dGVUcmFuc2xhdGlvblBhcnRzW2xvY2FsZV0gPSB7fVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByb3V0ZVRyYW5zbGF0aW9ucykge1xuICAgICAgICB0aGlzLnJvdXRlVHJhbnNsYXRpb25QYXJ0c1tsb2NhbGVdW2tleV0gPSByb3V0ZVRyYW5zbGF0aW9uc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHJhbnNsYXRlUm91dGUgKHthcmdzLCBsb2NhbGl6ZWRSb3V0ZXMsIHBhdGhQYXJ0cywgdXJsfSkge1xuICAgIGxldCBvcHRpb25zXG5cbiAgICAvLyBFeHRyYWN0IG9wdGlvbnMgZnJvbSBhcmdzIGlmIGFueVxuICAgIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV1cblxuICAgIGlmIChsYXN0QXJnICYmIHR5cGVvZiBsYXN0QXJnID09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdzLnBvcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIC8vIFRha2UgbG9jYWxlIGZyb20gb3B0aW9ucyBpZiBnaXZlbiBvciBmYWxsIGJhY2sgdG8gZmFsbGJhY2tcbiAgICBjb25zdCB7bG9jYWxlLCBob3N0LCBwb3J0LCBwcm90b2NvbCwgLi4ucmVzdE9wdGlvbnN9ID0gb3B0aW9uc1xuXG4gICAgaWYgKGxvY2FsaXplZFJvdXRlcykge1xuICAgICAgLy8gUHV0IHRvZ2V0aGVyIHJvdXRlIHdpdGggdmFyaWFibGVzIGFuZCBzdGF0aWMgdHJhbnNsYXRlZCBwYXJ0cyAod2hpY2ggd2VyZSB0cmFuc2xhdGVkIGFuZCBjYWNoZWQgcHJldmlvdXNseSlcbiAgICAgIGxldCB0cmFuc2xhdGVkUm91dGUgPSBkaWdnKGxvY2FsaXplZFJvdXRlcywgbG9jYWxlIHx8IHRoaXMuZ2V0TG9jYWxlKCkpXG4gICAgICAgIC5tYXAoKHBhdGhQYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhdGhQYXJ0LnR5cGUgPT0gXCJwYXRoUGFydFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFBhcnQubmFtZVxuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aFBhcnQudHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgIC8vIEFyZ3MgbWlnaHQgbm90IGNvbnRhaW4gdGhlIHJpZ2h0IGFtb3VudCBvZiB2YXJpYWJsZXMsIHNvIGRvbnQgY2hhbmdlIHRoaXMgdG8gJ2RpZ2cnXG4gICAgICAgICAgICByZXR1cm4gZGlnKGFyZ3MsIGRpZ2cocGF0aFBhcnQsIFwiY291bnRcIikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIHBhdGggcGFydCB0eXBlOiAke3BhdGhQYXJ0LnR5cGV9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiL1wiKVxuXG4gICAgICBpZiAocmVzdE9wdGlvbnMgJiYgT2JqZWN0LmtleXMocmVzdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJhbnNsYXRlZFJvdXRlICs9IGA/JHtxcy5zdHJpbmdpZnkocmVzdE9wdGlvbnMsIHtlbmNvZGVyOiB1cmxFbmNvZGV9KX1gXG4gICAgICB9XG5cbiAgICAgIGlmICh1cmwpIHJldHVybiB0aGlzLmFkZEhvc3RUb1JvdXRlKHtob3N0LCBwb3J0LCBwcm90b2NvbCwgdHJhbnNsYXRlZFJvdXRlfSlcblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRSb3V0ZVxuICAgIH0gZWxzZSBpZiAocGF0aFBhcnRzKSB7XG4gICAgICAvLyBQdXQgdG9nZXRoZXIgcm91dGUgd2l0aCB2YXJpYWJsZXMgYW5kIHN0YXRpYyB0cmFuc2xhdGVkIHBhcnRzICh3aGljaCB3ZXJlIHRyYW5zbGF0ZWQgYW5kIGNhY2hlZCBwcmV2aW91c2x5KVxuICAgICAgbGV0IHRyYW5zbGF0ZWRSb3V0ZSA9IHBhdGhQYXJ0c1xuICAgICAgICAubWFwKChwYXRoUGFydCkgPT4ge1xuICAgICAgICAgIGlmIChwYXRoUGFydC50eXBlID09IFwicGF0aFBhcnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhQYXJ0Lm5hbWVcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhQYXJ0LnR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlnZyhhcmdzLCBkaWdnKHBhdGhQYXJ0LCBcImNvdW50XCIpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBwYXRoIHBhcnQgdHlwZTogJHtwYXRoUGFydC50eXBlfWApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIi9cIilcblxuICAgICAgaWYgKHJlc3RPcHRpb25zICYmIE9iamVjdC5rZXlzKHJlc3RPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyYW5zbGF0ZWRSb3V0ZSArPSBgPyR7cXMuc3RyaW5naWZ5KHJlc3RPcHRpb25zLCB7ZW5jb2RlcjogdXJsRW5jb2RlfSl9YFxuICAgICAgfVxuXG4gICAgICBpZiAodXJsKSByZXR1cm4gdGhpcy5hZGRIb3N0VG9Sb3V0ZSh7aG9zdCwgcG9ydCwgcHJvdG9jb2wsIHRyYW5zbGF0ZWRSb3V0ZX0pXG5cbiAgICAgIHJldHVybiB0cmFuc2xhdGVkUm91dGVcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgc3RhdGVcIilcbiAgfVxuXG4gIGFkZEhvc3RUb1JvdXRlICh7aG9zdCwgcG9ydCwgcHJvdG9jb2wsIHRyYW5zbGF0ZWRSb3V0ZX0pIHtcbiAgICBsZXQgZnVsbFVybCA9IFwiXCJcblxuICAgIGNvbnN0IGhvc3RUb1VzZSA9IGhvc3QgfHwgZ2xvYmFsVGhpcy5sb2NhdGlvbiAmJiBnbG9iYWxUaGlzLmxvY2F0aW9uLmhvc3RcbiAgICBjb25zdCBwb3J0VG9Vc2UgPSBwb3J0IHx8IGdsb2JhbFRoaXMubG9jYXRpb24gJiYgZ2xvYmFsVGhpcy5sb2NhdGlvbi5wb3J0XG5cbiAgICBpZiAoIWhvc3RUb1VzZSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRldGVjdCBob3N0XCIpXG5cbiAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgIGZ1bGxVcmwgKz0gYCR7cHJvdG9jb2x9Oi8vYFxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5sb2NhdGlvbiAmJiBnbG9iYWxUaGlzLmxvY2F0aW9uLnByb3RvY29sKSB7XG4gICAgICBmdWxsVXJsICs9IGAke2dsb2JhbFRoaXMubG9jYXRpb24ucHJvdG9jb2x9Ly9gXG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGxVcmwgKz0gXCJodHRwczovL1wiXG4gICAgfVxuXG4gICAgZnVsbFVybCArPSBob3N0VG9Vc2VcblxuICAgIGlmIChwb3J0VG9Vc2UgJiYgKChwcm90b2NvbCA9PSBcImh0dHBcIiAmJiBwb3J0VG9Vc2UgIT0gODApIHx8IChwcm90b2NvbCA9PSBcImh0dHBzXCIgJiYgcG9ydCAhPSA0NDMpKSkge1xuICAgICAgZnVsbFVybCArPSBgOiR7cG9ydFRvVXNlfWBcbiAgICB9XG5cbiAgICBmdWxsVXJsICs9IHRyYW5zbGF0ZWRSb3V0ZVxuXG4gICAgcmV0dXJuIGZ1bGxVcmxcbiAgfVxufVxuIl19