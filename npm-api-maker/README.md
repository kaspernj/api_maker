# @kaspernj/api-maker

Client-side library for ApiMaker-powered Rails APIs. It provides model classes, collections, and UI helpers for web and React Native apps, backed by the JSON payloads generated by the ApiMaker server gem.

## Installation

```bash
npm install @kaspernj/api-maker
```

## Quick start

ApiMaker models are generated from `model-recipes.json` (usually emitted by the Rails gem). Import the models and set up the shared config before making requests.

```js
import config from "@kaspernj/api-maker/build/config"
import Models from "@kaspernj/api-maker/build/models"
import history from "./history"
import routes from "./routes"

config.setHistory(history)
config.setLinkTo((path) => history.push(path))
config.setNavigation({
  navigate: (routeName, params) => history.push(routes[routeName](params))
})
config.setRoutes(routes)
config.setCurrenciesCollection([
  ["US Dollar", "usd"],
  ["Euro", "eur"]
])

const users = await Models.User.ransack({name_cont: "sam"}).per(20).toArray()
const user = await Models.User.find("a0f3842b-1e4c-4e9d-8f2d-cd021e5a9b6a")
```

## Models and collections

Models are generated from the server recipes and inherit `BaseModel`. Collections let you compose queries fluently and then execute them with `toArray()`.

```js
const activeProjects = await Models.Project
  .ransack({state_eq: "active"})
  .preload(["owner"])
  .sort("created_at desc")
  .toArray()

const firstProject = await Models.Project.ransack({name_cont: "api"}).first()
const totalCount = await Models.Project.ransack().count()
```

## Relationship loading and preloading

Relationship accessors are generated from the recipe. For a relationship named `account`, you get:

- `user.account()` to read a cached relationship.
- `user.loadAccount()` to fetch it from the API.

Reading a relationship before it is loaded raises `NotLoadedError` unless the model is new.

### Requesting preloads from the server

Use `preload` on a collection to have the server include related records in the response. ApiMaker stores those models in the relationship cache automatically.

```js
const users = await Models.User
  .ransack()
  .preload(["account", "roles"])
  .toArray()

users[0].account()
```

### Manually preloading with `preloadRelationship`

When you already have related model instances (for example after creating records or from another response), you can mark a relationship as loaded without another request.

```js
const user = await Models.User.find("a0f3842b-1e4c-4e9d-8f2d-cd021e5a9b6a")
const account = await Models.Account.find("f6c0b2b3-0a37-4e6e-ae3a-2e6a38e3953d")

user.preloadRelationship("account", account)
user.account()
```

`preloadRelationship` accepts:

- A single model (for `belongs_to` / `has_one` relationships).
- An array of models (for `has_many` relationships).
- `null` when the relationship is known to be empty.

The relationship name is stored in `snake_case`, so `preloadRelationship("Account", account)` and `preloadRelationship("account", account)` are equivalent. After preloading, both `account()` and `loadAccount()` return the cached value without hitting the network.

## Configuration notes

`config` is a shared singleton. Some helpers (forms, routing, navigation, and money inputs) require config values like `history`, `linkTo`, `navigation`, and `currenciesCollection` to be set. If a required value is missing, the getter throws an error to avoid silent failures.

## Related docs

The server-side setup, resource definitions, and serializers live in the main ApiMaker repository README.
