/**
 * @typedef {Object} MutexOptions
 * @property {boolean} [debug]
 */
/**
 * Mutex for running async work sequentially.
 */
export default class Mutex {
    /**
     * @param {MutexOptions} [args]
     */
    constructor(args?: MutexOptions);
    _debug: boolean | undefined;
    _readers: number;
    _processQueueTimeout: NodeJS.Timeout | null;
    /** @type {Array<MutexQueueItem<unknown>>} */
    _syncQueue: Array<MutexQueueItem<unknown>>;
    /**
     * Run a job with exclusive access.
     * @template T
     * @param {() => (T | Promise<T>)} callback
     * @returns {Promise<T>}
     */
    sync<T>(callback: () => (T | Promise<T>)): Promise<T>;
    /**
     * @template T
     * @param {() => (T | Promise<T>)} callback
     * @returns {Promise<T>}
     */
    runJobInstantly<T>(callback: () => (T | Promise<T>)): Promise<T>;
    /**
     * @param {string} message
     * @returns {void}
     */
    _log(message: string): void;
    /**
     * @returns {void}
     */
    _processQueueLater(): void;
    /**
     * @returns {Promise<void>}
     */
    _processQueue: () => Promise<void>;
    /**
     * @param {MutexQueueItem<unknown>} item
     * @returns {Promise<void>}
     */
    _runJob(item: MutexQueueItem<unknown>): Promise<void>;
}
export type MutexOptions = {
    debug?: boolean | undefined;
};
export type MutexQueueItem<T> = {
    callback: () => (T | Promise<T>);
    resolve: (value: T) => void;
    reject: (error: unknown) => void;
};
//# sourceMappingURL=mutex.d.ts.map