{
  "manifest": {
    "name": "tapable",
    "version": "2.3.0",
    "description": "Just a little module for plugins.",
    "homepage": "https://github.com/webpack/tapable",
    "repository": {
      "type": "git",
      "url": "http://github.com/webpack/tapable.git"
    },
    "funding": {
      "type": "opencollective",
      "url": "https://opencollective.com/webpack"
    },
    "license": "MIT",
    "author": {
      "name": "Tobias Koppers @sokra"
    },
    "main": "lib/index.js",
    "browser": {
      "util": "./lib/util-browser.js"
    },
    "types": "./tapable.d.ts",
    "files": [
      "lib",
      "!lib/__tests__",
      "tapable.d.ts"
    ],
    "scripts": {
      "lint": "yarn lint:code && yarn fmt:check",
      "lint:code": "eslint --cache .",
      "fmt": "yarn fmt:base --log-level warn --write",
      "fmt:check": "yarn fmt:base --check",
      "fmt:base": "node ./node_modules/prettier/bin/prettier.cjs --cache --ignore-unknown .",
      "fix": "yarn fix:code && yarn fmt",
      "fix:code": "yarn lint:code --fix",
      "test": "jest"
    },
    "jest": {
      "transform": {
        "__tests__[\\\\/].+\\.js$": "babel-jest"
      }
    },
    "devDependencies": {
      "@babel/core": "^7.4.4",
      "@babel/preset-env": "^7.4.4",
      "@eslint/js": "^9.28.0",
      "@eslint/markdown": "^7.1.0",
      "@stylistic/eslint-plugin": "^5.2.3",
      "babel-jest": "^24.8.0",
      "globals": "^16.2.0",
      "eslint": "^9.28.0",
      "eslint-config-webpack": "^4.6.3",
      "eslint-config-prettier": "^10.1.5",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jest": "^29.0.1",
      "eslint-plugin-n": "^17.19.0",
      "eslint-plugin-prettier": "^5.4.1",
      "eslint-plugin-unicorn": "^60.0.0",
      "jest": "^24.8.0",
      "prettier": "^3.5.3",
      "prettier-1": "npm:prettier@^1"
    },
    "engines": {
      "node": ">=6"
    },
    "_registry": "npm",
    "_loc": "/home/dev/api_maker/.yarn-cache/v6/npm-tapable-2.3.0-7e3ea6d5ca31ba8e078b560f0d83ce9a14aa8be6-integrity/node_modules/tapable/package.json",
    "readmeFilename": "README.md",
    "readme": "# Tapable\n\nThe tapable package exposes many Hook classes, which can be used to create hooks for plugins.\n\n```javascript\nconst {\n\tAsyncParallelBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesWaterfallHook,\n\tSyncBailHook,\n\tSyncHook,\n\tSyncLoopHook,\n\tSyncWaterfallHook\n} = require(\"tapable\");\n```\n\n## Installation\n\n```shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n```js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n```js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n```js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n```js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", (newSpeed) =>\n\tconsole.log(`Accelerating to ${newSpeed}`)\n);\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n```js\nmyCar.hooks.calculateRoutes.tapPromise(\n\t\"GoogleMapsPlugin\",\n\t(source, target, routesList) =>\n\t\t// return a promise\n\t\tgoogle.maps.findRoute(source, target).then((route) => {\n\t\t\troutesList.add(route);\n\t\t})\n);\nmyCar.hooks.calculateRoutes.tapAsync(\n\t\"BingMapsPlugin\",\n\t(source, target, routesList, callback) => {\n\t\tbing.findRoute(source, target, (err, route) => {\n\t\t\tif (err) return callback(err);\n\t\t\troutesList.add(route);\n\t\t\t// call the callback\n\t\t\tcallback();\n\t\t});\n\t}\n);\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\n\t\"CachedRoutesPlugin\",\n\t(source, target, routesList) => {\n\t\tconst cachedRoute = cache.get(source, target);\n\t\tif (cachedRoute) routesList.add(cachedRoute);\n\t}\n);\n```\n\nThe class declaring these hooks needs to call them:\n\n```js\nclass Car {\n\t/**\n\t * You won't get returned value from SyncHook or AsyncParallelHook,\n\t * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t */\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes\n\t\t\t.promise(source, target, routesList)\n\t\t\t.then((res) =>\n\t\t\t\t// res is undefined for AsyncParallelHook\n\t\t\t\troutesList.getRoutes()\n\t\t\t);\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, (err) => {\n\t\t\tif (err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n\n- The number of registered plugins (none, one, many)\n- The kind of registered plugins (sync, async, promise)\n- The used call method (sync, async, promise)\n- The number of arguments\n- Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n- Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n- **Waterfall**. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n- **Bail**. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n- **Loop**. When a plugin in a loop hook returns a non-undefined value the hook will restart from the first plugin. It will loop until all plugins return undefined.\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n- **Sync**. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n- **AsyncSeries**. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n- **AsyncParallel**. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n```js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n});\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n```js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap(\n\t{\n\t\tname: \"NoisePlugin\",\n\t\tcontext: true\n\t},\n\t(context, newSpeed) => {\n\t\tif (context && context.hasMuffler) {\n\t\t\tconsole.log(\"Silence...\");\n\t\t} else {\n\t\t\tconsole.log(\"Vroom!\");\n\t\t}\n\t}\n);\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n```js\nconst keyedHook = new HookMap((key) => new SyncHook([\"arg\"]));\n```\n\n```js\nkeyedHook.for(\"some-key\").tap(\"MyPlugin\", (arg) => {\n\t/* ... */\n});\nkeyedHook.for(\"some-key\").tapAsync(\"MyPlugin\", (arg, callback) => {\n\t/* ... */\n});\nkeyedHook.for(\"some-key\").tapPromise(\"MyPlugin\", (arg) => {\n\t/* ... */\n});\n```\n\n```js\nconst hook = keyedHook.get(\"some-key\");\nif (hook !== undefined) {\n\thook.callAsync(\"arg\", (err) => {\n\t\t/* ... */\n\t});\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n```ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void;\n\ttapAsync: (\n\t\tname: string | Tap,\n\t\tfn: (\n\t\t\tcontext?,\n\t\t\t...args,\n\t\t\tcallback: (err: Error | null, result: Result) => void\n\t\t) => void\n\t) => void;\n\ttapPromise: (\n\t\tname: string | Tap,\n\t\tfn: (context?, ...args) => Promise<Result>\n\t) => void;\n\tintercept: (interceptor: HookInterceptor) => void;\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void;\n\tloop: (context?, ...args) => void;\n\ttap: (context?, tap: Tap) => void;\n\tregister: (tap: Tap) => Tap;\n\tcontext: boolean;\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook;\n\tintercept: (interceptor: HookMapInterceptor) => void;\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook;\n}\n\ninterface Tap {\n\tname: string;\n\ttype: string;\n\tfn: Function;\n\tstage: number;\n\tcontext: boolean;\n\tbefore?: string | Array;\n}\n```\n\nProtected (only for the class containing the hook):\n\n```ts\ninterface Hook {\n\tisUsed: () => boolean;\n\tcall: (...args) => Result;\n\tpromise: (...args) => Promise<Result>;\n\tcallAsync: (\n\t\t...args,\n\t\tcallback: (err: Error | null, result: Result) => void\n\t) => void;\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined;\n\tfor: (key: any) => Hook;\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n```js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n",
    "licenseText": "The MIT License\n\nCopyright JS Foundation and other contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/tapable/-/tapable-2.3.0.tgz#7e3ea6d5ca31ba8e078b560f0d83ce9a14aa8be6",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/tapable/-/tapable-2.3.0.tgz",
    "hash": "7e3ea6d5ca31ba8e078b560f0d83ce9a14aa8be6",
    "integrity": "sha512-g9ljZiwki/LfxmQADO3dEY1CbpmXT5Hm2fJ+QaGKwSXUylMybePR7/67YW7jOrrvjEgL1Fmz5kzyAjWVWLlucg==",
    "registry": "npm",
    "packageName": "tapable",
    "cacheIntegrity": "sha512-g9ljZiwki/LfxmQADO3dEY1CbpmXT5Hm2fJ+QaGKwSXUylMybePR7/67YW7jOrrvjEgL1Fmz5kzyAjWVWLlucg== sha1-fj6m1coxuo4Hi1YPDYPOmhSqi+Y="
  },
  "registry": "npm",
  "hash": "7e3ea6d5ca31ba8e078b560f0d83ce9a14aa8be6"
}