/* eslint-disable func-style, sort-imports */
import { useCallback } from "react";
import { Dimensions } from "react-native";
import * as inflection from "inflection";
import isExpo from "./is-expo.js";
import { resolveWindowWidthFromSources } from "./resolve-window-width.js";
import useEventEmitter from "./use-event-emitter.js";
import useEventListener from "./use-event-listener.js";
import useShape from "set-state-compare/build/use-shape.js";
const DEFAULT_BREAKPOINTS = [
    ["xxl", 1400],
    ["xl", 1200],
    ["lg", 992],
    ["md", 768],
    ["sm", 576],
    ["xs", 0]
];
/**
 * @param {Array<[string, number]>} breakpoints Ordered list of breakpoints.
 * @param {() => number} getWindowWidth Window width resolver.
 * @returns {object} Breakpoint state map.
 */
function calculateBreakPoint(breakpoints, getWindowWidth) {
    const windowWidth = getWindowWidth();
    const result = {};
    for (const breakpointData of breakpoints) {
        const breakpoint = breakpointData[0];
        const width = breakpointData[1];
        if (!result.name && windowWidth >= width) {
            result.name = breakpoint;
            result[`${breakpoint}Down`] = true;
        }
        else {
            result[`${breakpoint}Down`] = !result.name;
        }
        result[`${breakpoint}Up`] = Boolean(result.name);
    }
    if (result.name) {
        return result;
    }
    throw new Error(`Couldn't not find breakpoint from window width: ${windowWidth}`);
}
/**
 * @param {object} options Hook configuration.
 * @param {() => Array<[string, number]>} [options.getBreakpoints] Breakpoint provider.
 * @param {() => object} [options.getEvents] Event emitter provider.
 * @param {string} [options.eventName] Event name for breakpoints.
 * @param {() => number} [options.getWindowWidth] Window width resolver override.
 * @param {boolean} [options.isExpo] Force Expo environment detection.
 * @param {object} [options.dimensions] Dimensions implementation override.
 * @returns {Function} Configured breakpoint hook.
 */
const createUseBreakpoint = (options = {}) => {
    const { getBreakpoints = () => DEFAULT_BREAKPOINTS, getEvents = () => null, eventName = "onBreakpointsChange", getWindowWidth, isExpo: isExpoOverride, dimensions: dimensionsOverride } = options;
    const actualDimensions = dimensionsOverride || Dimensions;
    const actualIsExpo = isExpoOverride ?? isExpo;
    const resolveWindowWidth = getWindowWidth || (() => {
        const windowObject = typeof globalThis === "undefined"
            ? undefined
            : /** @type {{innerWidth?: number} | undefined} */ ( /** @type {any} */(globalThis).window);
        // Use 'window.innerWidth' outside Expo because sometimes window width excludes scroll
        return resolveWindowWidthFromSources({
            dimensions: actualDimensions,
            isExpo: actualIsExpo,
            windowObject
        });
    });
    const useBreakpoint = (args = {}) => {
        var _a;
        const s = useShape(args);
        const events = getEvents();
        (_a = s.meta).breakpoints || (_a.breakpoints = getBreakpoints());
        const checkAndUpdateBreakpoint = useCallback(() => {
            const breakpoint = calculateBreakPoint(s.m.breakpoints, resolveWindowWidth);
            if (breakpoint.name != s.s.breakpoint.name) {
                s.set({ breakpoint });
            }
        }, []);
        const onDimensionsChange = useCallback(() => {
            checkAndUpdateBreakpoint();
        }, []);
        const onBreakpointsChange = useCallback(({ newValue }) => {
            s.meta.breakpoints = newValue;
            checkAndUpdateBreakpoint();
        }, []);
        s.useStates({
            breakpoint: () => calculateBreakPoint(s.m.breakpoints, resolveWindowWidth)
        });
        const styling = useCallback((args) => {
            // eslint-disable-next-line prefer-object-spread
            const style = Object.assign({}, args.base);
            for (const breakpointData of s.m.breakpoints) {
                const breakpoint = breakpointData[0];
                const breakpointWithSizeType = `${breakpoint}${inflection.camelize("down")}`;
                if (args[breakpointWithSizeType] && s.s.breakpoint[breakpointWithSizeType]) {
                    Object.assign(style, args[breakpointWithSizeType]);
                }
            }
            for (const breakpointData of [...s.m.breakpoints].reverse()) {
                const breakpoint = breakpointData[0];
                const breakpointWithSizeType = `${breakpoint}${inflection.camelize("up")}`;
                if (args[breakpointWithSizeType] && s.s.breakpoint[breakpointWithSizeType]) {
                    Object.assign(style, args[breakpointWithSizeType]);
                }
            }
            return style;
        }, []);
        useEventEmitter(events, eventName, onBreakpointsChange);
        useEventListener(actualDimensions, "change", onDimensionsChange);
        return {
            styling,
            ...s.s.breakpoint
        };
    };
    return useBreakpoint;
};
export default createUseBreakpoint;
