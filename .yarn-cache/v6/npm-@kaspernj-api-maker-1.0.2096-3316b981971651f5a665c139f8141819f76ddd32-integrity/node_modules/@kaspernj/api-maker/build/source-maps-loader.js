import * as stackTraceParser from "stacktrace-parser";
import Logger from "./logger.js";
import { SourceMapConsumer } from "source-map";
import uniqunize from "uniqunize";
// Sometimes this needs to be called and sometimes not
if (SourceMapConsumer.initialize) {
    SourceMapConsumer.initialize({
        "lib/mappings.wasm": "https://unpkg.com/source-map@0.7.4/lib/mappings.wasm"
    });
}
const logger = new Logger({ name: "ApiMaker / SourceMapsLoader" });
export default class SourceMapsLoader {
    constructor() {
        this.isLoadingSourceMaps = false;
        this.sourceMaps = [];
        this.srcLoaded = {};
    }
    loadSourceMapsForScriptTags(callback) {
        this.loadSourceMapsForScriptTagsCallback = callback;
    }
    sourceMapForSource(callback) {
        this.sourceMapForSourceCallback = callback;
    }
    async loadSourceMaps(error) {
        if (!error)
            throw new Error("No error was given to SourceMapsLoader#loadSourceMaps");
        this.isLoadingSourceMaps = true;
        try {
            const promises = [];
            const sources = this.getSources(error);
            for (const source of sources) {
                if (source.originalUrl && !this.srcLoaded[source.originalUrl]) {
                    this.srcLoaded[source.originalUrl] = true;
                    const promise = this.loadSourceMapForSource(source);
                    promises.push(promise);
                }
            }
            await Promise.all(promises);
        }
        finally {
            this.isLoadingSourceMaps = false;
        }
    }
    getSources(error) {
        let sources = this.getSourcesFromScripts();
        if (error)
            sources = sources.concat(this.getSourcesFromError(error));
        return uniqunize(sources, (source) => source.originalUrl);
    }
    getSourcesFromError(error) {
        const stack = stackTraceParser.parse(error.stack);
        const sources = [];
        for (const trace of stack) {
            const file = trace.file;
            if (file != "\u003Canonymous>") {
                const sourceMapUrl = this.getMapURL({ src: file });
                if (sourceMapUrl) {
                    logger.debug(() => `Found source map from error: ${sourceMapUrl}`);
                    sources.push({ originalUrl: file, sourceMapUrl });
                }
                else {
                    logger.debug(() => `Coudn't get source map from: ${file}`);
                }
            }
        }
        return sources;
    }
    getSourcesFromScripts() {
        const scripts = document.querySelectorAll("script");
        const sources = [];
        for (const script of scripts) {
            const sourceMapUrl = this.getMapURL({ script, src: script.src });
            if (sourceMapUrl) {
                logger.debug(() => `Found source map from script: ${sourceMapUrl}`);
                sources.push({ originalUrl: script.src, sourceMapUrl });
            }
        }
        return sources;
    }
    getMapURL({ script, src }) {
        const url = this.loadUrl(src);
        const originalUrl = `${url.origin}${url.pathname}`;
        if (this.sourceMapForSourceCallback) {
            // Use custom callback to resolve which map-file to download
            return this.sourceMapForSourceCallback({ originalUrl, script, src, url });
        }
        else if (this.includeMapURL(src)) {
            // Default to original URL with '.map' appended
            return `${originalUrl}.map`;
        }
    }
    includeMapURL = (src) => src.includes("/packs/");
    async loadSourceMapForSource({ originalUrl, sourceMapUrl }) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", sourceMapUrl, true);
        try {
            await this.loadXhr(xhr, sourceMapUrl);
        }
        catch {
            console.log(`Couldn't load source map from: ${sourceMapUrl}: ${xhr.responseText}`);
            return;
        }
        const consumer = await new SourceMapConsumer(xhr.responseText);
        if (consumer) {
            this.sourceMaps.push({ consumer, originalUrl });
        }
    }
    loadUrl(url) {
        const parser = document.createElement("a");
        parser.href = url;
        return parser;
    }
    loadXhr(xhr, url) {
        return new Promise((resolve, reject) => {
            xhr.onload = () => {
                if (xhr.status == 200) {
                    resolve();
                }
                else {
                    reject(new Error(`HTTP request failed with ${xhr.status} for ${url}`));
                }
            };
            xhr.send();
        });
    }
    parseStackTrace(stackTrace) {
        return this.getStackTraceData(stackTrace)
            .map((traceData) => `at ${traceData.methodName} (${traceData.fileString})`);
    }
    getStackTraceData(stackTrace) {
        const stack = stackTraceParser.parse(stackTrace);
        const newSourceMap = [];
        for (const trace of stack) {
            const sourceMapData = this.sourceMaps.find((sourceMapData) => sourceMapData.originalUrl == trace.file);
            let filePath, fileString, original;
            if (sourceMapData) {
                original = sourceMapData.consumer.originalPositionFor({
                    line: trace.lineNumber,
                    column: trace.column
                });
            }
            if (original && original.source) {
                filePath = original.source.replace(/^webpack:\/\/(app|)\//, "");
                fileString = `${filePath}:${original.line}`;
                if (original.column) {
                    fileString += `:${original.column}`;
                }
            }
            else {
                filePath = trace.file;
                fileString = `${filePath}:${trace.lineNumber}`;
                if (trace.column) {
                    fileString += `:${trace.column}`;
                }
            }
            newSourceMap.push({
                filePath,
                fileString,
                methodName: trace.methodName
            });
        }
        return newSourceMap;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlLW1hcHMtbG9hZGVyLmpzIiwic291cmNlUm9vdCI6Ii9zcmMvIiwic291cmNlcyI6WyJzb3VyY2UtbWFwcy1sb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLGdCQUFnQixNQUFNLG1CQUFtQixDQUFBO0FBQ3JELE9BQU8sTUFBTSxNQUFNLGFBQWEsQ0FBQTtBQUNoQyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxZQUFZLENBQUE7QUFDNUMsT0FBTyxTQUFTLE1BQU0sV0FBVyxDQUFBO0FBRWpDLHNEQUFzRDtBQUN0RCxJQUFJLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ2pDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQztRQUMzQixtQkFBbUIsRUFBRSxzREFBc0Q7S0FDNUUsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVELE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLEVBQUMsSUFBSSxFQUFFLDZCQUE2QixFQUFDLENBQUMsQ0FBQTtBQUVoRSxNQUFNLENBQUMsT0FBTyxPQUFPLGdCQUFnQjtJQUNuQztRQUNFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUE7UUFDaEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUE7UUFDcEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUE7SUFDckIsQ0FBQztJQUVELDJCQUEyQixDQUFDLFFBQVE7UUFDbEMsSUFBSSxDQUFDLG1DQUFtQyxHQUFHLFFBQVEsQ0FBQTtJQUNyRCxDQUFDO0lBRUQsa0JBQWtCLENBQUMsUUFBUTtRQUN6QixJQUFJLENBQUMsMEJBQTBCLEdBQUcsUUFBUSxDQUFBO0lBQzVDLENBQUM7SUFFRCxLQUFLLENBQUMsY0FBYyxDQUFDLEtBQUs7UUFDeEIsSUFBSSxDQUFDLEtBQUs7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUE7UUFFcEYsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FB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RTlDLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUNqQixVQUFVLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUE7Z0JBQ2xDLENBQUM7WUFDSCxDQUFDO1lBRUQsWUFBWSxDQUFDLElBQUksQ0FBQztnQkFDaEIsUUFBUTtnQkFDUixVQUFVO2dCQUNWLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTthQUM3QixDQUFDLENBQUE7UUFDSixDQUFDO1FBRUQsT0FBTyxZQUFZLENBQUE7SUFDckIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3RhY2tUcmFjZVBhcnNlciBmcm9tIFwic3RhY2t0cmFjZS1wYXJzZXJcIlxuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi9sb2dnZXIuanNcIlxuaW1wb3J0IHtTb3VyY2VNYXBDb25zdW1lcn0gZnJvbSBcInNvdXJjZS1tYXBcIlxuaW1wb3J0IHVuaXF1bml6ZSBmcm9tIFwidW5pcXVuaXplXCJcblxuLy8gU29tZXRpbWVzIHRoaXMgbmVlZHMgdG8gYmUgY2FsbGVkIGFuZCBzb21ldGltZXMgbm90XG5pZiAoU291cmNlTWFwQ29uc3VtZXIuaW5pdGlhbGl6ZSkge1xuICBTb3VyY2VNYXBDb25zdW1lci5pbml0aWFsaXplKHtcbiAgICBcImxpYi9tYXBwaW5ncy53YXNtXCI6IFwiaHR0cHM6Ly91bnBrZy5jb20vc291cmNlLW1hcEAwLjcuNC9saWIvbWFwcGluZ3Mud2FzbVwiXG4gIH0pXG59XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoe25hbWU6IFwiQXBpTWFrZXIgLyBTb3VyY2VNYXBzTG9hZGVyXCJ9KVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb3VyY2VNYXBzTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pc0xvYWRpbmdTb3VyY2VNYXBzID0gZmFsc2VcbiAgICB0aGlzLnNvdXJjZU1hcHMgPSBbXVxuICAgIHRoaXMuc3JjTG9hZGVkID0ge31cbiAgfVxuXG4gIGxvYWRTb3VyY2VNYXBzRm9yU2NyaXB0VGFncyhjYWxsYmFjaykge1xuICAgIHRoaXMubG9hZFNvdXJjZU1hcHNGb3JTY3JpcHRUYWdzQ2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG5cbiAgc291cmNlTWFwRm9yU291cmNlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zb3VyY2VNYXBGb3JTb3VyY2VDYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cblxuICBhc3luYyBsb2FkU291cmNlTWFwcyhlcnJvcikge1xuICAgIGlmICghZXJyb3IpIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHdhcyBnaXZlbiB0byBTb3VyY2VNYXBzTG9hZGVyI2xvYWRTb3VyY2VNYXBzXCIpXG5cbiAgICB0aGlzLmlzTG9hZGluZ1NvdXJjZU1hcHMgPSB0cnVlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgY29uc3Qgc291cmNlcyA9IHRoaXMuZ2V0U291cmNlcyhlcnJvcilcblxuICAgICAgZm9yKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2Uub3JpZ2luYWxVcmwgJiYgIXRoaXMuc3JjTG9hZGVkW3NvdXJjZS5vcmlnaW5hbFVybF0pIHtcbiAgICAgICAgICB0aGlzLnNyY0xvYWRlZFtzb3VyY2Uub3JpZ2luYWxVcmxdID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubG9hZFNvdXJjZU1hcEZvclNvdXJjZShzb3VyY2UpXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzTG9hZGluZ1NvdXJjZU1hcHMgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGdldFNvdXJjZXMoZXJyb3IpIHtcbiAgICBsZXQgc291cmNlcyA9IHRoaXMuZ2V0U291cmNlc0Zyb21TY3JpcHRzKClcblxuICAgIGlmIChlcnJvcikgc291cmNlcyA9IHNvdXJjZXMuY29uY2F0KHRoaXMuZ2V0U291cmNlc0Zyb21FcnJvcihlcnJvcikpXG5cbiAgICByZXR1cm4gdW5pcXVuaXplKHNvdXJjZXMsIChzb3VyY2UpID0+IHNvdXJjZS5vcmlnaW5hbFVybClcbiAgfVxuXG4gIGdldFNvdXJjZXNGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrVHJhY2VQYXJzZXIucGFyc2UoZXJyb3Iuc3RhY2spXG4gICAgY29uc3Qgc291cmNlcyA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IHRyYWNlIG9mIHN0YWNrKSB7XG4gICAgICBjb25zdCBmaWxlID0gdHJhY2UuZmlsZVxuXG4gICAgICBpZiAoZmlsZSAhPSBcIlxcdTAwM0Nhbm9ueW1vdXM+XCIpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTWFwVXJsID0gdGhpcy5nZXRNYXBVUkwoe3NyYzogZmlsZX0pXG5cbiAgICAgICAgaWYgKHNvdXJjZU1hcFVybCkge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygoKSA9PiBgRm91bmQgc291cmNlIG1hcCBmcm9tIGVycm9yOiAke3NvdXJjZU1hcFVybH1gKVxuXG4gICAgICAgICAgc291cmNlcy5wdXNoKHtvcmlnaW5hbFVybDogZmlsZSwgc291cmNlTWFwVXJsfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoKCkgPT4gYENvdWRuJ3QgZ2V0IHNvdXJjZSBtYXAgZnJvbTogJHtmaWxlfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlc1xuICB9XG5cbiAgZ2V0U291cmNlc0Zyb21TY3JpcHRzKCkge1xuICAgIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0XCIpXG4gICAgY29uc3Qgc291cmNlcyA9IFtdXG5cbiAgICBmb3IgKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKSB7XG4gICAgICBjb25zdCBzb3VyY2VNYXBVcmwgPSB0aGlzLmdldE1hcFVSTCh7c2NyaXB0LCBzcmM6IHNjcmlwdC5zcmN9KVxuXG4gICAgICBpZiAoc291cmNlTWFwVXJsKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygoKSA9PiBgRm91bmQgc291cmNlIG1hcCBmcm9tIHNjcmlwdDogJHtzb3VyY2VNYXBVcmx9YClcbiAgICAgICAgc291cmNlcy5wdXNoKHtvcmlnaW5hbFVybDogc2NyaXB0LnNyYywgc291cmNlTWFwVXJsfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlc1xuICB9XG5cbiAgZ2V0TWFwVVJMKHtzY3JpcHQsIHNyY30pIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmxvYWRVcmwoc3JjKVxuICAgIGNvbnN0IG9yaWdpbmFsVXJsID0gYCR7dXJsLm9yaWdpbn0ke3VybC5wYXRobmFtZX1gXG5cbiAgICBpZiAodGhpcy5zb3VyY2VNYXBGb3JTb3VyY2VDYWxsYmFjaykge1xuICAgICAgLy8gVXNlIGN1c3RvbSBjYWxsYmFjayB0byByZXNvbHZlIHdoaWNoIG1hcC1maWxlIHRvIGRvd25sb2FkXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBGb3JTb3VyY2VDYWxsYmFjayh7b3JpZ2luYWxVcmwsIHNjcmlwdCwgc3JjLCB1cmx9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbmNsdWRlTWFwVVJMKHNyYykpIHtcbiAgICAgIC8vIERlZmF1bHQgdG8gb3JpZ2luYWwgVVJMIHdpdGggJy5tYXAnIGFwcGVuZGVkXG4gICAgICByZXR1cm4gYCR7b3JpZ2luYWxVcmx9Lm1hcGBcbiAgICB9XG4gIH1cblxuICBpbmNsdWRlTWFwVVJMID0gKHNyYykgPT4gc3JjLmluY2x1ZGVzKFwiL3BhY2tzL1wiKVxuXG4gIGFzeW5jIGxvYWRTb3VyY2VNYXBGb3JTb3VyY2Uoe29yaWdpbmFsVXJsLCBzb3VyY2VNYXBVcmx9KSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIHhoci5vcGVuKFwiR0VUXCIsIHNvdXJjZU1hcFVybCwgdHJ1ZSlcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRYaHIoeGhyLCBzb3VyY2VNYXBVcmwpXG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmxvZyhgQ291bGRuJ3QgbG9hZCBzb3VyY2UgbWFwIGZyb206ICR7c291cmNlTWFwVXJsfTogJHt4aHIucmVzcG9uc2VUZXh0fWApXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNvbnN1bWVyID0gYXdhaXQgbmV3IFNvdXJjZU1hcENvbnN1bWVyKHhoci5yZXNwb25zZVRleHQpXG5cbiAgICBpZiAoY29uc3VtZXIpIHtcbiAgICAgIHRoaXMuc291cmNlTWFwcy5wdXNoKHtjb25zdW1lciwgb3JpZ2luYWxVcmx9KVxuICAgIH1cbiAgfVxuXG4gIGxvYWRVcmwodXJsKSB7XG4gICAgY29uc3QgcGFyc2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcblxuICAgIHBhcnNlci5ocmVmID0gdXJsXG5cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBsb2FkWGhyKHhociwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEhUVFAgcmVxdWVzdCBmYWlsZWQgd2l0aCAke3hoci5zdGF0dXN9IGZvciAke3VybH1gKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeGhyLnNlbmQoKVxuICAgIH0pXG4gIH1cblxuICBwYXJzZVN0YWNrVHJhY2Uoc3RhY2tUcmFjZSkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YWNrVHJhY2VEYXRhKHN0YWNrVHJhY2UpXG4gICAgICAubWFwKCh0cmFjZURhdGEpID0+IGBhdCAke3RyYWNlRGF0YS5tZXRob2ROYW1lfSAoJHt0cmFjZURhdGEuZmlsZVN0cmluZ30pYClcbiAgfVxuXG4gIGdldFN0YWNrVHJhY2VEYXRhKHN0YWNrVHJhY2UpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrVHJhY2VQYXJzZXIucGFyc2Uoc3RhY2tUcmFjZSlcbiAgICBjb25zdCBuZXdTb3VyY2VNYXAgPSBbXVxuXG4gICAgZm9yIChjb25zdCB0cmFjZSBvZiBzdGFjaykge1xuICAgICAgY29uc3Qgc291cmNlTWFwRGF0YSA9IHRoaXMuc291cmNlTWFwcy5maW5kKChzb3VyY2VNYXBEYXRhKSA9PiBzb3VyY2VNYXBEYXRhLm9yaWdpbmFsVXJsID09IHRyYWNlLmZpbGUpXG5cbiAgICAgIGxldCBmaWxlUGF0aCwgZmlsZVN0cmluZywgb3JpZ2luYWxcblxuICAgICAgaWYgKHNvdXJjZU1hcERhdGEpIHtcbiAgICAgICAgb3JpZ2luYWwgPSBzb3VyY2VNYXBEYXRhLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IHRyYWNlLmxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiB0cmFjZS5jb2x1bW5cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNvdXJjZSkge1xuICAgICAgICBmaWxlUGF0aCA9IG9yaWdpbmFsLnNvdXJjZS5yZXBsYWNlKC9ed2VicGFjazpcXC9cXC8oYXBwfClcXC8vLCBcIlwiKVxuICAgICAgICBmaWxlU3RyaW5nID0gYCR7ZmlsZVBhdGh9OiR7b3JpZ2luYWwubGluZX1gXG5cbiAgICAgICAgaWYgKG9yaWdpbmFsLmNvbHVtbikge1xuICAgICAgICAgIGZpbGVTdHJpbmcgKz0gYDoke29yaWdpbmFsLmNvbHVtbn1gXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGVQYXRoID0gdHJhY2UuZmlsZVxuICAgICAgICBmaWxlU3RyaW5nID0gYCR7ZmlsZVBhdGh9OiR7dHJhY2UubGluZU51bWJlcn1gXG5cbiAgICAgICAgaWYgKHRyYWNlLmNvbHVtbikge1xuICAgICAgICAgIGZpbGVTdHJpbmcgKz0gYDoke3RyYWNlLmNvbHVtbn1gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3U291cmNlTWFwLnB1c2goe1xuICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgZmlsZVN0cmluZyxcbiAgICAgICAgbWV0aG9kTmFtZTogdHJhY2UubWV0aG9kTmFtZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U291cmNlTWFwXG4gIH1cbn1cbiJdfQ==