import * as inflection from "inflection";
import { dig, digg, digs } from "diggerize";
import qs from "qs";
import urlEncode from "./url-encode.js";
/**
 * @typedef {{type: "pathPart", name: string} | {type: "variable", count: number}} PathPart
 */
/**
 * @typedef {{args: Array<unknown>, localizedRoutes?: Record<string, PathPart[]>, pathParts?: PathPart[], url?: boolean}} TranslateRouteArgs
 */
/**
 * @typedef {{host?: string, port?: number|string, protocol?: string, translatedRoute: string}} HostRouteArgs
 */
/**
 * @typedef {{locale?: string, host?: string, port?: number|string, protocol?: string} & Record<string, unknown>} RouteOptions
 */
/**
 * Builds paths and URLs from route definitions for native usage.
 */
export default class ApiMakerRoutesNative {
    /** @param {{getLocale: () => string}} options */
    constructor({ getLocale }) {
        this.getLocale = getLocale;
        this.routeDefinitions = [];
        this.routeTranslationParts = {};
    }
    /**
     * @param {object} routeDefinitions
     * @param {{localized?: boolean}=} routeDefinitionArgs
     * @returns {void}
     */
    loadRouteDefinitions(routeDefinitions, routeDefinitionArgs) {
        for (const routeDefinition of digg(routeDefinitions, "routes")) {
            const { name, path } = digs(routeDefinition, "name", "path");
            const rawPathParts = path.split("/");
            const pathMethodName = `${inflection.camelize(name, true)}Path`;
            const urlMethodName = `${inflection.camelize(name, true)}Url`;
            if (routeDefinitionArgs && routeDefinitionArgs.localized) {
                const localizedRoutes = /** @type {Record<string, PathPart[]>} */ {};
                for (const locale in this.routeTranslationParts) {
                    let variableCount = 0;
                    const localizedPathParts = /** @type {PathPart[]} */ [
                        { type: "pathPart", name: "" },
                        { type: "pathPart", name: locale }
                    ];
                    for (let i = 1; i < rawPathParts.length; i++) {
                        const pathPart = rawPathParts[i];
                        const variableMatch = pathPart.match(/^:([A-z_]+)$/);
                        // eslint-disable-next-line max-depth
                        if (variableMatch) {
                            localizedPathParts.push({ type: "variable", count: variableCount++ });
                        }
                        else if (pathPart) {
                            const name = this.i18n.t(`routes.${pathPart}`, null, { default: pathPart, locale });
                            localizedPathParts.push({ type: "pathPart", name });
                        }
                    }
                    localizedRoutes[locale] = localizedPathParts;
                }
                this[pathMethodName] = (...args) => this.translateRoute({ args, localizedRoutes });
                this[urlMethodName] = (...args) => this.translateRoute({ args, localizedRoutes, url: true });
            }
            else {
                let variableCount = 0;
                const pathParts = /** @type {PathPart[]} */ rawPathParts.map((pathPart) => {
                    const variableMatch = pathPart.match(/^:([A-z_]+)$/);
                    if (variableMatch) {
                        return { type: "variable", count: variableCount++ };
                    }
                    else {
                        return { type: "pathPart", name: pathPart };
                    }
                });
                this[pathMethodName] = (...args) => this.translateRoute({ args, pathParts });
                this[urlMethodName] = (...args) => this.translateRoute({ args, pathParts, url: true });
            }
        }
    }
    /**
     * @param {object} i18n
     * @returns {void}
     */
    loadRouteTranslations(i18n) {
        this.i18n = i18n;
        const locales = digg(i18n, "locales");
        for (const locale in locales) {
            const routeTranslations = dig(locales, locale, "routes");
            if (routeTranslations) {
                if (!(locale in this.routeTranslationParts))
                    this.routeTranslationParts[locale] = {};
                for (const key in routeTranslations) {
                    this.routeTranslationParts[locale][key] = routeTranslations[key];
                }
            }
        }
    }
    /**
     * @param {TranslateRouteArgs} options
     * @returns {string}
     */
    translateRoute({ args, localizedRoutes, pathParts, url }) {
        let options = /** @type {RouteOptions} */ {};
        // Extract options from args if any
        const lastArg = args[args.length - 1];
        if (lastArg && typeof lastArg == "object") {
            options = /** @type {RouteOptions} */ args.pop();
        }
        else {
            options = {};
        }
        // Take locale from options if given or fall back to fallback
        const { locale, host, port, protocol, ...restOptions } = options;
        if (localizedRoutes) {
            // Put together route with variables and static translated parts (which were translated and cached previously)
            const translatedPathParts = /** @type {PathPart[]} */ digg(localizedRoutes, locale || this.getLocale());
            let translatedRoute = translatedPathParts
                .map((pathPart) => {
                if (pathPart.type == "pathPart") {
                    return pathPart.name;
                }
                else if (pathPart.type == "variable") {
                    // Args might not contain the right amount of variables, so dont change this to 'digg'
                    return dig(args, digg(pathPart, "count"));
                }
                else {
                    throw new Error("Unhandled path part type");
                }
            })
                .join("/");
            if (restOptions && Object.keys(restOptions).length > 0) {
                translatedRoute += `?${qs.stringify(restOptions, { encoder: urlEncode })}`;
            }
            if (url)
                return this.addHostToRoute({ host, port, protocol, translatedRoute });
            return translatedRoute;
        }
        else if (pathParts) {
            // Put together route with variables and static translated parts (which were translated and cached previously)
            let translatedRoute = pathParts
                .map((pathPart) => {
                if (pathPart.type == "pathPart") {
                    return pathPart.name;
                }
                else if (pathPart.type == "variable") {
                    return digg(args, digg(pathPart, "count"));
                }
                else {
                    throw new Error("Unhandled path part type");
                }
            })
                .join("/");
            if (restOptions && Object.keys(restOptions).length > 0) {
                translatedRoute += `?${qs.stringify(restOptions, { encoder: urlEncode })}`;
            }
            if (url)
                return this.addHostToRoute({ host, port, protocol, translatedRoute });
            return translatedRoute;
        }
        throw new Error("Unhandled state");
    }
    /**
     * @param {HostRouteArgs} options
     * @returns {string}
     */
    addHostToRoute({ host, port, protocol, translatedRoute }) {
        let fullUrl = "";
        const hostToUse = host || (globalThis.location ? globalThis.location.host : undefined);
        const portToUse = port || (globalThis.location ? globalThis.location.port : undefined);
        if (!hostToUse)
            throw new Error("Unable to detect host");
        if (protocol) {
            fullUrl += `${protocol}://`;
        }
        else if (globalThis.location && globalThis.location.protocol) {
            fullUrl += `${globalThis.location.protocol}//`;
        }
        else {
            fullUrl += "https://";
        }
        fullUrl += hostToUse;
        const isHttpNonDefaultPort = protocol == "http" && portToUse != 80;
        const isHttpsNonDefaultPort = protocol == "https" && port != 443;
        if (portToUse && (isHttpNonDefaultPort || isHttpsNonDefaultPort)) {
            fullUrl += `:${portToUse}`;
        }
        fullUrl += translatedRoute;
        return fullUrl;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVzLW5hdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIvc3JjLyIsInNvdXJjZXMiOlsicm91dGVzLW5hdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssVUFBVSxNQUFNLFlBQVksQ0FBQTtBQUN4QyxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsTUFBTSxXQUFXLENBQUE7QUFDekMsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFBO0FBQ25CLE9BQU8sU0FBUyxNQUFNLGlCQUFpQixDQUFBO0FBRXZDOztHQUVHO0FBQ0g7O0dBRUc7QUFDSDs7R0FFRztBQUNIOztHQUVHO0FBRUg7O0dBRUc7QUFDSCxNQUFNLENBQUMsT0FBTyxPQUFPLG9CQUFvQjtJQUN2QyxpREFBaUQ7SUFDakQsWUFBYSxFQUFDLFNBQVMsRUFBQztRQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQTtRQUMxQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFBO1FBQzFCLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxFQUFFLENBQUE7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxvQkFBb0IsQ0FBRSxnQkFBZ0IsRUFBRSxtQkFBbUI7UUFDekQsS0FBSyxNQUFNLGVBQWUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUMvRCxNQUFNLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBQyxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFBO1lBQzFELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDcEMsTUFBTSxjQUFjLEdBQUcsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFBO1lBQy9ELE1BQU0sYUFBYSxHQUFHLEdBQUcsVUFBVSxDQUFDLFFBQVEs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QUFBO1FBRWhFLElBQUksU0FBUyxJQUFJLENBQUMsb0JBQW9CLElBQUkscUJBQXFCLENBQUMsRUFBRSxDQUFDO1lBQ2pFLE9BQU8sSUFBSSxJQUFJLFNBQVMsRUFBRSxDQUFBO1FBQzVCLENBQUM7UUFFRCxPQUFPLElBQUksZUFBZSxDQUFBO1FBRTFCLE9BQU8sT0FBTyxDQUFBO0lBQ2hCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGluZmxlY3Rpb24gZnJvbSBcImluZmxlY3Rpb25cIlxuaW1wb3J0IHtkaWcsIGRpZ2csIGRpZ3N9IGZyb20gXCJkaWdnZXJpemVcIlxuaW1wb3J0IHFzIGZyb20gXCJxc1wiXG5pbXBvcnQgdXJsRW5jb2RlIGZyb20gXCIuL3VybC1lbmNvZGUuanNcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHt7dHlwZTogXCJwYXRoUGFydFwiLCBuYW1lOiBzdHJpbmd9IHwge3R5cGU6IFwidmFyaWFibGVcIiwgY291bnQ6IG51bWJlcn19IFBhdGhQYXJ0XG4gKi9cbi8qKlxuICogQHR5cGVkZWYge3thcmdzOiBBcnJheTx1bmtub3duPiwgbG9jYWxpemVkUm91dGVzPzogUmVjb3JkPHN0cmluZywgUGF0aFBhcnRbXT4sIHBhdGhQYXJ0cz86IFBhdGhQYXJ0W10sIHVybD86IGJvb2xlYW59fSBUcmFuc2xhdGVSb3V0ZUFyZ3NcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7e2hvc3Q/OiBzdHJpbmcsIHBvcnQ/OiBudW1iZXJ8c3RyaW5nLCBwcm90b2NvbD86IHN0cmluZywgdHJhbnNsYXRlZFJvdXRlOiBzdHJpbmd9fSBIb3N0Um91dGVBcmdzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge3tsb2NhbGU/OiBzdHJpbmcsIGhvc3Q/OiBzdHJpbmcsIHBvcnQ/OiBudW1iZXJ8c3RyaW5nLCBwcm90b2NvbD86IHN0cmluZ30gJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gUm91dGVPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgcGF0aHMgYW5kIFVSTHMgZnJvbSByb3V0ZSBkZWZpbml0aW9ucyBmb3IgbmF0aXZlIHVzYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcGlNYWtlclJvdXRlc05hdGl2ZSB7XG4gIC8qKiBAcGFyYW0ge3tnZXRMb2NhbGU6ICgpID0+IHN0cmluZ319IG9wdGlvbnMgKi9cbiAgY29uc3RydWN0b3IgKHtnZXRMb2NhbGV9KSB7XG4gICAgdGhpcy5nZXRMb2NhbGUgPSBnZXRMb2NhbGVcbiAgICB0aGlzLnJvdXRlRGVmaW5pdGlvbnMgPSBbXVxuICAgIHRoaXMucm91dGVUcmFuc2xhdGlvblBhcnRzID0ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcm91dGVEZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge3tsb2NhbGl6ZWQ/OiBib29sZWFufT19IHJvdXRlRGVmaW5pdGlvbkFyZ3NcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBsb2FkUm91dGVEZWZpbml0aW9ucyAocm91dGVEZWZpbml0aW9ucywgcm91dGVEZWZpbml0aW9uQXJncykge1xuICAgIGZvciAoY29uc3Qgcm91dGVEZWZpbml0aW9uIG9mIGRpZ2cocm91dGVEZWZpbml0aW9ucywgXCJyb3V0ZXNcIikpIHtcbiAgICAgIGNvbnN0IHtuYW1lLCBwYXRofSA9IGRpZ3Mocm91dGVEZWZpbml0aW9uLCBcIm5hbWVcIiwgXCJwYXRoXCIpXG4gICAgICBjb25zdCByYXdQYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKVxuICAgICAgY29uc3QgcGF0aE1ldGhvZE5hbWUgPSBgJHtpbmZsZWN0aW9uLmNhbWVsaXplKG5hbWUsIHRydWUpfVBhdGhgXG4gICAgICBjb25zdCB1cmxNZXRob2ROYW1lID0gYCR7aW5mbGVjdGlvbi5jYW1lbGl6ZShuYW1lLCB0cnVlKX1VcmxgXG5cbiAgICAgIGlmIChyb3V0ZURlZmluaXRpb25BcmdzICYmIHJvdXRlRGVmaW5pdGlvbkFyZ3MubG9jYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsaXplZFJvdXRlcyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgUGF0aFBhcnRbXT59ICovIHt9XG5cbiAgICAgICAgZm9yIChjb25zdCBsb2NhbGUgaW4gdGhpcy5yb3V0ZVRyYW5zbGF0aW9uUGFydHMpIHtcbiAgICAgICAgICBsZXQgdmFyaWFibGVDb3VudCA9IDBcblxuICAgICAgICAgIGNvbnN0IGxvY2FsaXplZFBhdGhQYXJ0cyA9IC8qKiBAdHlwZSB7UGF0aFBhcnRbXX0gKi8gW1xuICAgICAgICAgICAge3R5cGU6IFwicGF0aFBhcnRcIiwgbmFtZTogXCJcIn0sXG4gICAgICAgICAgICB7dHlwZTogXCJwYXRoUGFydFwiLCBuYW1lOiBsb2NhbGV9XG4gICAgICAgICAgXVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYXdQYXRoUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0ID0gcmF3UGF0aFBhcnRzW2ldXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZU1hdGNoID0gcGF0aFBhcnQubWF0Y2goL146KFtBLXpfXSspJC8pXG5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZU1hdGNoKSB7XG4gICAgICAgICAgICAgIGxvY2FsaXplZFBhdGhQYXJ0cy5wdXNoKHt0eXBlOiBcInZhcmlhYmxlXCIsIGNvdW50OiB2YXJpYWJsZUNvdW50Kyt9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXRoUGFydCkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5pMThuLnQoYHJvdXRlcy4ke3BhdGhQYXJ0fWAsIG51bGwsIHtkZWZhdWx0OiBwYXRoUGFydCwgbG9jYWxlfSlcblxuICAgICAgICAgICAgICBsb2NhbGl6ZWRQYXRoUGFydHMucHVzaCh7dHlwZTogXCJwYXRoUGFydFwiLCBuYW1lfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsb2NhbGl6ZWRSb3V0ZXNbbG9jYWxlXSA9IGxvY2FsaXplZFBhdGhQYXJ0c1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1twYXRoTWV0aG9kTmFtZV0gPSAoLi4uYXJncykgPT4gdGhpcy50cmFuc2xhdGVSb3V0ZSh7YXJncywgbG9jYWxpemVkUm91dGVzfSlcbiAgICAgICAgdGhpc1t1cmxNZXRob2ROYW1lXSA9ICguLi5hcmdzKSA9PiB0aGlzLnRyYW5zbGF0ZVJvdXRlKHthcmdzLCBsb2NhbGl6ZWRSb3V0ZXMsIHVybDogdHJ1ZX0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmFyaWFibGVDb3VudCA9IDBcblxuICAgICAgICBjb25zdCBwYXRoUGFydHMgPSAvKiogQHR5cGUge1BhdGhQYXJ0W119ICovIHJhd1BhdGhQYXJ0cy5tYXAoKHBhdGhQYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFyaWFibGVNYXRjaCA9IHBhdGhQYXJ0Lm1hdGNoKC9eOihbQS16X10rKSQvKVxuXG4gICAgICAgICAgaWYgKHZhcmlhYmxlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJ2YXJpYWJsZVwiLCBjb3VudDogdmFyaWFibGVDb3VudCsrfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwicGF0aFBhcnRcIiwgbmFtZTogcGF0aFBhcnR9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXNbcGF0aE1ldGhvZE5hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMudHJhbnNsYXRlUm91dGUoe2FyZ3MsIHBhdGhQYXJ0c30pXG4gICAgICAgIHRoaXNbdXJsTWV0aG9kTmFtZV0gPSAoLi4uYXJncykgPT4gdGhpcy50cmFuc2xhdGVSb3V0ZSh7YXJncywgcGF0aFBhcnRzLCB1cmw6IHRydWV9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaTE4blxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGxvYWRSb3V0ZVRyYW5zbGF0aW9ucyAoaTE4bikge1xuICAgIHRoaXMuaTE4biA9IGkxOG5cbiAgICBjb25zdCBsb2NhbGVzID0gZGlnZyhpMThuLCBcImxvY2FsZXNcIilcblxuICAgIGZvciAoY29uc3QgbG9jYWxlIGluIGxvY2FsZXMpIHtcbiAgICAgIGNvbnN0IHJvdXRlVHJhbnNsYXRpb25zID0gZGlnKGxvY2FsZXMsIGxvY2FsZSwgXCJyb3V0ZXNcIilcblxuICAgICAgaWYgKHJvdXRlVHJhbnNsYXRpb25zKSB7XG4gICAgICAgIGlmICghKGxvY2FsZSBpbiB0aGlzLnJvdXRlVHJhbnNsYXRpb25QYXJ0cykpIHRoaXMucm91dGVUcmFuc2xhdGlvblBhcnRzW2xvY2FsZV0gPSB7fVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJvdXRlVHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5yb3V0ZVRyYW5zbGF0aW9uUGFydHNbbG9jYWxlXVtrZXldID0gcm91dGVUcmFuc2xhdGlvbnNba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNsYXRlUm91dGVBcmdzfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0cmFuc2xhdGVSb3V0ZSAoe2FyZ3MsIGxvY2FsaXplZFJvdXRlcywgcGF0aFBhcnRzLCB1cmx9KSB7XG4gICAgbGV0IG9wdGlvbnMgPSAvKiogQHR5cGUge1JvdXRlT3B0aW9uc30gKi8ge31cblxuICAgIC8vIEV4dHJhY3Qgb3B0aW9ucyBmcm9tIGFyZ3MgaWYgYW55XG4gICAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKGxhc3RBcmcgJiYgdHlwZW9mIGxhc3RBcmcgPT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7Um91dGVPcHRpb25zfSAqLyBhcmdzLnBvcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIC8vIFRha2UgbG9jYWxlIGZyb20gb3B0aW9ucyBpZiBnaXZlbiBvciBmYWxsIGJhY2sgdG8gZmFsbGJhY2tcbiAgICBjb25zdCB7bG9jYWxlLCBob3N0LCBwb3J0LCBwcm90b2NvbCwgLi4ucmVzdE9wdGlvbnN9ID0gb3B0aW9uc1xuXG4gICAgaWYgKGxvY2FsaXplZFJvdXRlcykge1xuICAgICAgLy8gUHV0IHRvZ2V0aGVyIHJvdXRlIHdpdGggdmFyaWFibGVzIGFuZCBzdGF0aWMgdHJhbnNsYXRlZCBwYXJ0cyAod2hpY2ggd2VyZSB0cmFuc2xhdGVkIGFuZCBjYWNoZWQgcHJldmlvdXNseSlcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWRQYXRoUGFydHMgPSAvKiogQHR5cGUge1BhdGhQYXJ0W119ICovIGRpZ2cobG9jYWxpemVkUm91dGVzLCBsb2NhbGUgfHwgdGhpcy5nZXRMb2NhbGUoKSlcbiAgICAgIGxldCB0cmFuc2xhdGVkUm91dGUgPSB0cmFuc2xhdGVkUGF0aFBhcnRzXG4gICAgICAgIC5tYXAoKHBhdGhQYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhdGhQYXJ0LnR5cGUgPT0gXCJwYXRoUGFydFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFBhcnQubmFtZVxuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aFBhcnQudHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgIC8vIEFyZ3MgbWlnaHQgbm90IGNvbnRhaW4gdGhlIHJpZ2h0IGFtb3VudCBvZiB2YXJpYWJsZXMsIHNvIGRvbnQgY2hhbmdlIHRoaXMgdG8gJ2RpZ2cnXG4gICAgICAgICAgICByZXR1cm4gZGlnKGFyZ3MsIGRpZ2cocGF0aFBhcnQsIFwiY291bnRcIikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBwYXRoIHBhcnQgdHlwZVwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIvXCIpXG5cbiAgICAgIGlmIChyZXN0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhyZXN0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICB0cmFuc2xhdGVkUm91dGUgKz0gYD8ke3FzLnN0cmluZ2lmeShyZXN0T3B0aW9ucywge2VuY29kZXI6IHVybEVuY29kZX0pfWBcbiAgICAgIH1cblxuICAgICAgaWYgKHVybCkgcmV0dXJuIHRoaXMuYWRkSG9zdFRvUm91dGUoe2hvc3QsIHBvcnQsIHByb3RvY29sLCB0cmFuc2xhdGVkUm91dGV9KVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlZFJvdXRlXG4gICAgfSBlbHNlIGlmIChwYXRoUGFydHMpIHtcbiAgICAgIC8vIFB1dCB0b2dldGhlciByb3V0ZSB3aXRoIHZhcmlhYmxlcyBhbmQgc3RhdGljIHRyYW5zbGF0ZWQgcGFydHMgKHdoaWNoIHdlcmUgdHJhbnNsYXRlZCBhbmQgY2FjaGVkIHByZXZpb3VzbHkpXG4gICAgICBsZXQgdHJhbnNsYXRlZFJvdXRlID0gcGF0aFBhcnRzXG4gICAgICAgIC5tYXAoKHBhdGhQYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhdGhQYXJ0LnR5cGUgPT0gXCJwYXRoUGFydFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFBhcnQubmFtZVxuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aFBhcnQudHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWdnKGFyZ3MsIGRpZ2cocGF0aFBhcnQsIFwiY291bnRcIikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBwYXRoIHBhcnQgdHlwZVwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIvXCIpXG5cbiAgICAgIGlmIChyZXN0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhyZXN0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICB0cmFuc2xhdGVkUm91dGUgKz0gYD8ke3FzLnN0cmluZ2lmeShyZXN0T3B0aW9ucywge2VuY29kZXI6IHVybEVuY29kZX0pfWBcbiAgICAgIH1cblxuICAgICAgaWYgKHVybCkgcmV0dXJuIHRoaXMuYWRkSG9zdFRvUm91dGUoe2hvc3QsIHBvcnQsIHByb3RvY29sLCB0cmFuc2xhdGVkUm91dGV9KVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlZFJvdXRlXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5oYW5kbGVkIHN0YXRlXCIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIb3N0Um91dGVBcmdzfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBhZGRIb3N0VG9Sb3V0ZSAoe2hvc3QsIHBvcnQsIHByb3RvY29sLCB0cmFuc2xhdGVkUm91dGV9KSB7XG4gICAgbGV0IGZ1bGxVcmwgPSBcIlwiXG5cbiAgICBjb25zdCBob3N0VG9Vc2UgPSBob3N0IHx8IChnbG9iYWxUaGlzLmxvY2F0aW9uID8gZ2xvYmFsVGhpcy5sb2NhdGlvbi5ob3N0IDogdW5kZWZpbmVkKVxuICAgIGNvbnN0IHBvcnRUb1VzZSA9IHBvcnQgfHwgKGdsb2JhbFRoaXMubG9jYXRpb24gPyBnbG9iYWxUaGlzLmxvY2F0aW9uLnBvcnQgOiB1bmRlZmluZWQpXG5cbiAgICBpZiAoIWhvc3RUb1VzZSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRldGVjdCBob3N0XCIpXG5cbiAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgIGZ1bGxVcmwgKz0gYCR7cHJvdG9jb2x9Oi8vYFxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5sb2NhdGlvbiAmJiBnbG9iYWxUaGlzLmxvY2F0aW9uLnByb3RvY29sKSB7XG4gICAgICBmdWxsVXJsICs9IGAke2dsb2JhbFRoaXMubG9jYXRpb24ucHJvdG9jb2x9Ly9gXG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGxVcmwgKz0gXCJodHRwczovL1wiXG4gICAgfVxuXG4gICAgZnVsbFVybCArPSBob3N0VG9Vc2VcblxuICAgIGNvbnN0IGlzSHR0cE5vbkRlZmF1bHRQb3J0ID0gcHJvdG9jb2wgPT0gXCJodHRwXCIgJiYgcG9ydFRvVXNlICE9IDgwXG4gICAgY29uc3QgaXNIdHRwc05vbkRlZmF1bHRQb3J0ID0gcHJvdG9jb2wgPT0gXCJodHRwc1wiICYmIHBvcnQgIT0gNDQzXG5cbiAgICBpZiAocG9ydFRvVXNlICYmIChpc0h0dHBOb25EZWZhdWx0UG9ydCB8fCBpc0h0dHBzTm9uRGVmYXVsdFBvcnQpKSB7XG4gICAgICBmdWxsVXJsICs9IGA6JHtwb3J0VG9Vc2V9YFxuICAgIH1cblxuICAgIGZ1bGxVcmwgKz0gdHJhbnNsYXRlZFJvdXRlXG5cbiAgICByZXR1cm4gZnVsbFVybFxuICB9XG59XG4iXX0=