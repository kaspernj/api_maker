export default class ApiMakerModelRecipesModelLoader {
    constructor({ modelRecipe, modelRecipesLoader }: {
        modelRecipe: any;
        modelRecipesLoader: any;
    });
    modelRecipesLoader: any;
    modelRecipe: any;
    createClass(): {
        new (args?: {}): {
            changes: {};
            newRecord: any;
            relationshipsCache: {};
            relationships: {};
            abilities: any;
            modelData: {};
            assignAttributes(newAttributes: Record<string, any>): void;
            attributes(): Record<string, any>;
            can(givenAbilityName: string): boolean;
            clone<Self extends BaseModel>(this: Self): Self;
            cacheKey(): number | string;
            localCacheKey(): string;
            fullCacheKey(): string;
            create(attributes?: Record<string, any>, options?: object): Promise<{
                model: BaseModel;
                response: object;
            }>;
            createRaw(rawData: FormData | Record<string, any>, options?: object): Promise<{
                model: /*elided*/ any;
                response: any;
            }>;
            destroy(): Promise<{
                model: BaseModel;
                response: object;
            }>;
            ensureAbilities(listOfAbilities: any): Promise<void>;
            getAttributes(): Record<string, any>;
            handleResponseError(response: any): void;
            identifierKey(): number | string;
            _identifierKey: string | number;
            isAssociationLoaded(associationName: any): boolean;
            isAssociationLoadedUnderscore(associationNameUnderscore: any): boolean;
            isAssociationPresent(associationName: any): boolean;
            isAttributeChanged(attributeName: string): boolean;
            isChanged(): boolean;
            isNewRecord(): boolean;
            isPersisted(): boolean;
            savedChangeToAttribute(attributeName: string): boolean;
            setNewModel(model: BaseModel): void;
            setNewModelData(model: any): void;
            previousModelData: any;
            _isDateChanged(oldValue: any, newValue: any): boolean;
            _isIntegerChanged(oldValue: any, newValue: any): boolean;
            _isStringChanged(oldValue: any, newValue: any): boolean;
            modelClassData(): ModelClassDataType;
            reload(): Promise<void>;
            save(): Promise<{
                model: BaseModel;
                response?: object;
            }>;
            saveRaw(rawData: any, options?: {}): Promise<{
                model: BaseModel;
                response: object;
            }>;
            update(newAttributes?: Record<string, any>, options?: ParseValidationErrorsOptions): Promise<{
                model: BaseModel;
                response?: object;
            }>;
            _refreshModelFromResponse(response: any): void;
            _refreshModelDataFromResponse(response: any): void;
            updateRaw(rawData: any, options?: {}): Promise<{
                response: any;
                model: /*elided*/ any;
            }>;
            isValid(): void;
            isValidOnServer(): Promise<{
                valid: any;
                errors: any;
            }>;
            modelClass<Self extends BaseModel>(this: Self): typeof BaseModel & (new (...args: any[]) => Self);
            preloadRelationship(relationshipName: any, model: any): void;
            markForDestruction(): void;
            _markedForDestruction: boolean;
            markedForDestruction(): boolean;
            uniqueKey(): number;
            uniqueKeyValue: number;
            _callMemberCommand: (args: any, commandArgs: any) => any;
            readAttribute(attributeName: string): any;
            readAttributeUnderscore(attributeName: string): any;
            isAttributeLoaded(attributeName: any): boolean;
            _isPresent(value: any): boolean;
            _loadBelongsToReflection(args: any, queryArgs?: {}): Promise<any>;
            _readBelongsToReflection({ reflectionName }: {
                reflectionName: any;
            }): any;
            _loadHasManyReflection<AssocMC extends typeof import("./base-model.js").default>(args: import("./collection.js").CollectionArgsType<AssocMC>, queryArgs?: import("./collection.js").QueryArgsType): Promise<InstanceType<AssocMC>[]>;
            _loadHasOneReflection<AssocMC extends typeof import("./base-model.js").default>(args: import("./collection.js").CollectionArgsType<AssocMC>, queryArgs?: import("./collection.js").QueryArgsType): Promise<InstanceType<AssocMC>>;
            _readHasOneReflection({ reflectionName }: {
                reflectionName: any;
            }): any;
            _readModelDataFromArgs(args: any): void;
            collection: any;
            preloadedRelationships: any;
            _readPreloadedRelationships(preloaded: any): void;
            primaryKey(): number | string;
        };
        readonly name: any;
        apiMakerType: string;
        attributes(): import("./base-model/attribute.js").default[];
        hasAttribute(attributeName: any): boolean;
        modelClassData(): ModelClassDataType;
        newCustomEvent: (validationErrors: import("./validation-errors.js").ValidationErrors) => CustomEvent;
        sendValidationErrorsEvent(validationErrors: import("./validation-errors.js").ValidationErrors, options?: {
            form?: object;
            throwValidationError?: boolean;
        }): void;
        find<T extends typeof BaseModel>(this: T, id: number | string): Promise<InstanceType<T>>;
        findOrCreateBy<T extends typeof BaseModel>(this: T, findOrCreateByArgs: Record<string, any>, args?: {}): Promise<InstanceType<T>>;
        modelName(): import("./model-name.js").default;
        primaryKey(): string;
        ransack<MC extends typeof BaseModel>(this: MC, query?: Record<string, any>): import("./collection.js").default<MC>;
        select<MC extends typeof BaseModel>(this: MC, select?: Record<string, any>): import("./collection.js").default<MC>;
        ransackableAssociations(): import("./base-model/reflection.js").default[];
        ransackableAttributes(): import("./base-model/attribute.js").default[];
        ransackableScopes(): import("./base-model/scope.js").default[];
        reflections(): import("./base-model/reflection.js").default[];
        reflection(name: any): import("./base-model/reflection.js").default;
        _token(): string;
        all<MC extends typeof BaseModel>(this: MC): Collection<MC>;
        parseValidationErrors({ error, model, options }: {
            error: any;
            model?: BaseModel;
            options: ParseValidationErrorsOptions;
        }): void;
        humanAttributeName(attributeName: any): any;
        snakeCase(string: string): string;
        _objectDataFromGivenRawData(rawData: FormData | Record<string, any>, options: object): Record<string, any>;
        _callCollectionCommand(args: any, commandArgs: any): Promise<any>;
        _postDataFromArgs(args: any): FormData;
    };
    addAttributeMethodsToModelClass(ModelClass: any, attributes: any): void;
    addQueryCommandsToModelClass(ModelClass: any, collectionCommands: any): void;
    addMemberCommandsToModelClass(ModelClass: any, memberCommands: any): void;
    addRelationshipsToModelClass(ModelClass: any, modelClassData: any, relationships: any): void;
    defineBelongsToGetMethod({ ModelClass, modelMethodName, relationshipName }: {
        ModelClass: any;
        modelMethodName: any;
        relationshipName: any;
    }): void;
    defineBelongsToLoadMethod({ foreignKey, klassPrimaryKey, ModelClass, modelRecipesLoader, loadMethodName, optionsPrimaryKey, relationshipName, resourceName }: {
        foreignKey: any;
        klassPrimaryKey: any;
        ModelClass: any;
        modelRecipesLoader: any;
        loadMethodName: any;
        optionsPrimaryKey: any;
        relationshipName: any;
        resourceName: any;
    }): void;
    defineHasManyGetMethod({ activeRecordName, className, foreignKey, ModelClass, modelMethodName, modelRecipesLoader, optionsAs, optionsPrimaryKey, optionsThrough, relationshipName, resourceName }: {
        activeRecordName: any;
        className: any;
        foreignKey: any;
        ModelClass: any;
        modelMethodName: any;
        modelRecipesLoader: any;
        optionsAs: any;
        optionsPrimaryKey: any;
        optionsThrough: any;
        relationshipName: any;
        resourceName: any;
    }): void;
    defineHasManyLoadMethod({ foreignKey, loadMethodName, ModelClass, modelClassData, modelRecipesLoader, optionsThrough, relationshipName, resourceName }: {
        foreignKey: any;
        loadMethodName: any;
        ModelClass: any;
        modelClassData: any;
        modelRecipesLoader: any;
        optionsThrough: any;
        relationshipName: any;
        resourceName: any;
    }): void;
    defineHasOneGetMethd({ ModelClass, modelMethodName, relationshipName }: {
        ModelClass: any;
        modelMethodName: any;
        relationshipName: any;
    }): void;
    defineHasOneLoadMethod({ activeRecordPrimaryKey, foreignKey, loadMethodName, ModelClass, modelClassData, modelRecipesLoader, optionsThrough, relationshipName, resourceName }: {
        activeRecordPrimaryKey: any;
        foreignKey: any;
        loadMethodName: any;
        ModelClass: any;
        modelClassData: any;
        modelRecipesLoader: any;
        optionsThrough: any;
        relationshipName: any;
        resourceName: any;
    }): void;
}
import BaseModel from "./base-model.js";
import Collection from "./collection.js";
//# sourceMappingURL=model-recipes-model-loader.d.ts.map