// @ts-check
import wait from "./wait.js";
/**
 * Waits for a callback to run without throwing an error and retries until the timeout is reached.
 * @template T
 * @overload
 * @param {() => (T | Promise<T>)} callback The callback.
 * @returns {Promise<T>} Resolves with the callback result.
 */
/**
 * Waits for a callback to run without throwing an error and retries until the timeout is reached.
 * @template T
 * @overload
 * @param {object} opts Options.
 * @param {number} [opts.timeout] The timeout in milliseconds (default: 5000)
 * @param {number} [opts.wait] The wait time in milliseconds (default: 50)
 * @param {() => (T | Promise<T>)} callback The callback.
 * @returns {Promise<T>} Resolves with the callback result.
 */
/**
 * Waits for a callback to run without throwing an error and retries until the timeout is reached.
 * @template T
 * @param {object | (() => (T | Promise<T>))} opts Options or the callback when no options are provided.
 * @param {() => (T | Promise<T>)} [callback] The callback.
 * @returns {Promise<T>} Resolves with the callback result.
 */
export default async function waitFor(opts, callback) {
    /** @type {object | undefined} */
    let options = opts;
    /** @type {(() => (T | Promise<T>)) | undefined} */
    let resolvedCallback = callback;
    if (typeof opts === "function") {
        resolvedCallback = opts;
        options = undefined;
    }
    if (resolvedCallback == undefined)
        throw new Error("Somehow callback is undefined");
    const { timeout: waitTimeout = 5000, wait: waitTime = 50, ...restOpts } = options || {};
    const restOptsKeys = Object.keys(restOpts);
    if (restOptsKeys.length > 0)
        throw new Error(`Unknown arguments given to waitFor: ${restOptsKeys.join(", ")}`);
    const startTime = Date.now();
    const endTime = startTime + waitTimeout;
    let lastError;
    while (Date.now() < endTime) {
        try {
            return await resolvedCallback();
        }
        catch (error) {
            lastError = error;
        }
        await wait(waitTime);
    }
    if (lastError) {
        throw lastError;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FpdC1mb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvd2FpdC1mb3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTtBQUVaLE9BQU8sSUFBSSxNQUFNLFdBQVcsQ0FBQTtBQUU1Qjs7Ozs7O0dBTUc7QUFDSDs7Ozs7Ozs7O0dBU0c7QUFDSDs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssVUFBVSxPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVE7SUFDbEQsaUNBQWlDO0lBQ2pDLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQTtJQUVsQixtREFBbUQ7SUFDbkQsSUFBSSxnQkFBZ0IsR0FBRyxRQUFRLENBQUE7SUFFL0IsSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUMvQixnQkFBZ0IsR0FBRyxJQUFJLENBQUE7UUFDdkIsT0FBTyxHQUFHLFNBQVMsQ0FBQTtJQUNyQixDQUFDO0lBRUQsSUFBSSxnQkFBZ0IsSUFBSSxTQUFTO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFBO0lBRW5GLE1BQU0sRUFBQyxPQUFPLEVBQUUsV0FBVyxHQUFHLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxHQUFHLEVBQUUsRUFBRSxHQUFHLFFBQVEsRUFBQyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUE7SUFDckYsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUUxQyxJQUFJLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO0lBQzlHLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUM1QixNQUFNLE9BQU8sR0FBRyxTQUFTLEdBQUcsV0FBVyxDQUFBO0lBQ3ZDLElBQUksU0FBUyxDQUFBO0lBRWIsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDO1lBQ0gsT0FBTyxNQUFNLGdCQUFnQixFQUFFLENBQUE7UUFDakMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixTQUFTLEdBQUcsS0FBSyxDQUFBO1FBQ25CLENBQUM7UUFDRCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUN0QixDQUFDO0lBRUQsSUFBSSxTQUFTLEVBQUUsQ0FBQztRQUNkLE1BQU0sU0FBUyxDQUFBO0lBQ2pCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB3YWl0IGZyb20gXCIuL3dhaXQuanNcIlxuXG4vKipcbiAqIFdhaXRzIGZvciBhIGNhbGxiYWNrIHRvIHJ1biB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yIGFuZCByZXRyaWVzIHVudGlsIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0geygpID0+IChUIHwgUHJvbWlzZTxUPil9IGNhbGxiYWNrIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fSBSZXNvbHZlcyB3aXRoIHRoZSBjYWxsYmFjayByZXN1bHQuXG4gKi9cbi8qKlxuICogV2FpdHMgZm9yIGEgY2FsbGJhY2sgdG8gcnVuIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IgYW5kIHJldHJpZXMgdW50aWwgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIE9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dF0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiA1MDAwKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndhaXRdIFRoZSB3YWl0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiA1MClcbiAqIEBwYXJhbSB7KCkgPT4gKFQgfCBQcm9taXNlPFQ+KX0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMge1Byb21pc2U8VD59IFJlc29sdmVzIHdpdGggdGhlIGNhbGxiYWNrIHJlc3VsdC5cbiAqL1xuLyoqXG4gKiBXYWl0cyBmb3IgYSBjYWxsYmFjayB0byBydW4gd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvciBhbmQgcmV0cmllcyB1bnRpbCB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7b2JqZWN0IHwgKCgpID0+IChUIHwgUHJvbWlzZTxUPikpfSBvcHRzIE9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIHdoZW4gbm8gb3B0aW9ucyBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0geygpID0+IChUIHwgUHJvbWlzZTxUPil9IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMge1Byb21pc2U8VD59IFJlc29sdmVzIHdpdGggdGhlIGNhbGxiYWNrIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvcihvcHRzLCBjYWxsYmFjaykge1xuICAvKiogQHR5cGUge29iamVjdCB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IG9wdGlvbnMgPSBvcHRzXG5cbiAgLyoqIEB0eXBlIHsoKCkgPT4gKFQgfCBQcm9taXNlPFQ+KSkgfCB1bmRlZmluZWR9ICovXG4gIGxldCByZXNvbHZlZENhbGxiYWNrID0gY2FsbGJhY2tcblxuICBpZiAodHlwZW9mIG9wdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlc29sdmVkQ2FsbGJhY2sgPSBvcHRzXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHJlc29sdmVkQ2FsbGJhY2sgPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJTb21laG93IGNhbGxiYWNrIGlzIHVuZGVmaW5lZFwiKVxuXG4gIGNvbnN0IHt0aW1lb3V0OiB3YWl0VGltZW91dCA9IDUwMDAsIHdhaXQ6IHdhaXRUaW1lID0gNTAsIC4uLnJlc3RPcHRzfSA9IG9wdGlvbnMgfHwge31cbiAgY29uc3QgcmVzdE9wdHNLZXlzID0gT2JqZWN0LmtleXMocmVzdE9wdHMpXG5cbiAgaWYgKHJlc3RPcHRzS2V5cy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXJndW1lbnRzIGdpdmVuIHRvIHdhaXRGb3I6ICR7cmVzdE9wdHNLZXlzLmpvaW4oXCIsIFwiKX1gKVxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gIGNvbnN0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyB3YWl0VGltZW91dFxuICBsZXQgbGFzdEVycm9yXG5cbiAgd2hpbGUgKERhdGUubm93KCkgPCBlbmRUaW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlZENhbGxiYWNrKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZXJyb3JcbiAgICB9XG4gICAgYXdhaXQgd2FpdCh3YWl0VGltZSlcbiAgfVxuXG4gIGlmIChsYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBsYXN0RXJyb3JcbiAgfVxufVxuIl19