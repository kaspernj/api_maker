{
  "manifest": {
    "name": "selfsigned",
    "version": "5.5.0",
    "description": "Generate self signed certificates private and public keys",
    "main": "index.js",
    "types": "index.d.ts",
    "scripts": {
      "test": "mocha -t 10000"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/jfromaniello/selfsigned.git"
    },
    "keywords": [
      "openssl",
      "self",
      "signed",
      "certificates",
      "x509",
      "webcrypto"
    ],
    "author": {
      "name": "José F. Romaniello",
      "email": "jfromaniello@gmail.com",
      "url": "http://joseoncode.com"
    },
    "contributors": [
      {
        "name": "Paolo Fragomeni",
        "email": "paolo@async.ly",
        "url": "http://async.ly"
      },
      {
        "name": "Charles Bushong",
        "email": "bushong1@gmail.com",
        "url": "http://github.com/bushong1"
      }
    ],
    "license": "MIT",
    "dependencies": {
      "@peculiar/x509": "^1.14.2",
      "pkijs": "^3.3.3"
    },
    "devDependencies": {
      "chai": "^4.3.4",
      "mocha": "^11.7.5"
    },
    "engines": {
      "node": ">=18"
    },
    "_registry": "npm",
    "_loc": "/home/dev/api_maker/.yarn-cache/v6/npm-selfsigned-5.5.0-4c9ab7c7c9f35f18fb6a9882c253eb0e6bd6557b-integrity/node_modules/selfsigned/package.json",
    "readmeFilename": "README.md",
    "readme": "# selfsigned\n\nGenerate self-signed X.509 certificates using Node.js native crypto.\n\n## Install\n\n```bash\nnpm install selfsigned\n```\n\n## Requirements\n\n- **Node.js >= 15.6.0** (for native WebCrypto support)\n\n## Usage\n\n**Version 5.0 is async-only.** The `generate()` function now returns a Promise.\n\n```js\nconst selfsigned = require('selfsigned');\n\nconst attrs = [{ name: 'commonName', value: 'contoso.com' }];\nconst pems = await selfsigned.generate(attrs);\nconsole.log(pems);\n```\n\n### Output\n\n```js\n{\n  private: '-----BEGIN PRIVATE KEY-----\\n...',\n  public: '-----BEGIN PUBLIC KEY-----\\n...',\n  cert: '-----BEGIN CERTIFICATE-----\\n...',\n  fingerprint: 'XX:XX:XX:...'\n}\n```\n\n## Options\n\n```js\nconst pems = await selfsigned.generate(null, {\n  keyType: 'rsa', // key type: 'rsa' or 'ec' (default: 'rsa')\n  keySize: 2048, // the size for the private key in bits (default: 2048, RSA only)\n  curve: 'P-256', // elliptic curve: 'P-256', 'P-384', or 'P-521' (default: 'P-256', EC only)\n  notBeforeDate: new Date(), // start of certificate validity (default: now)\n  notAfterDate: new Date('2026-01-01'), // end of certificate validity (default: notBeforeDate + 365 days)\n  algorithm: 'sha256', // sign the certificate with specified algorithm (default: 'sha1')\n  extensions: [{ name: 'basicConstraints', cA: true }], // certificate extensions array\n  clientCertificate: true, // generate client cert (default: false) - can also be an options object\n  ca: { key: '...', cert: '...' }, // CA key and cert for signing (default: self-signed)\n  passphrase: 'secret' // encrypt the private key with a passphrase (default: none)\n});\n```\n\n### Setting Custom Validity Period\n\nUse `notBeforeDate` and `notAfterDate` to control certificate validity:\n\n```js\n// Using date-fns\nconst { addDays, addYears } = require('date-fns');\n\nconst pems = await selfsigned.generate(null, {\n  notBeforeDate: new Date(),\n  notAfterDate: addDays(new Date(), 30) // Valid for 30 days\n});\n\n// Or with vanilla JS\nconst notBefore = new Date();\nconst notAfter = new Date(notBefore);\nnotAfter.setFullYear(notAfter.getFullYear() + 2); // Valid for 2 years\n\nconst pems = await selfsigned.generate(null, {\n  notBeforeDate: notBefore,\n  notAfterDate: notAfter\n});\n```\n\n### Supported Algorithms\n\n- `sha1` (default)\n- `sha256`\n- `sha384`\n- `sha512`\n\n### Custom Extensions\n\nYou can customize certificate extensions using the `extensions` option. This is useful for adding Subject Alternative Names (SANs) with IPv6 addresses, custom key usage, and more.\n\n```js\nconst pems = await selfsigned.generate(\n  [{ name: 'commonName', value: 'localhost' }],\n  {\n    extensions: [\n      {\n        name: 'basicConstraints',\n        cA: false\n      },\n      {\n        name: 'keyUsage',\n        digitalSignature: true,\n        keyEncipherment: true\n      },\n      {\n        name: 'subjectAltName',\n        altNames: [\n          { type: 2, value: 'localhost' },     // DNS\n          { type: 7, ip: '127.0.0.1' },        // IPv4\n          { type: 7, ip: '::1' }               // IPv6\n        ]\n      }\n    ]\n  }\n);\n```\n\n#### Supported Extensions\n\n**basicConstraints**\n```js\n{\n  name: 'basicConstraints',\n  cA: true,                    // is this a CA certificate?\n  pathLenConstraint: 0,        // max depth of valid cert chain (optional)\n  critical: true               // mark as critical extension\n}\n```\n\n**keyUsage**\n```js\n{\n  name: 'keyUsage',\n  digitalSignature: true,\n  nonRepudiation: true,\n  keyEncipherment: true,\n  dataEncipherment: true,\n  keyAgreement: true,\n  keyCertSign: true,          // for CA certificates\n  cRLSign: true,              // for CA certificates\n  encipherOnly: true,\n  decipherOnly: true,\n  critical: true\n}\n```\n\n**extKeyUsage** (Extended Key Usage)\n```js\n{\n  name: 'extKeyUsage',\n  serverAuth: true,           // TLS server authentication\n  clientAuth: true,           // TLS client authentication\n  codeSigning: true,\n  emailProtection: true,\n  timeStamping: true\n}\n```\n\n**subjectAltName** (Subject Alternative Name)\n```js\n{\n  name: 'subjectAltName',\n  altNames: [\n    { type: 1, value: 'user@example.com' },           // email (rfc822Name)\n    { type: 2, value: 'example.com' },                // DNS name\n    { type: 2, value: '*.example.com' },              // wildcard DNS\n    { type: 6, value: 'http://example.com/webid' },   // URI\n    { type: 7, ip: '127.0.0.1' },                     // IPv4 address\n    { type: 7, ip: '::1' }                            // IPv6 address\n  ]\n}\n```\n\n#### Default Extensions\n\nWhen no `extensions` option is provided (or an empty array), the following defaults are used:\n\n```js\n[\n  { name: 'basicConstraints', cA: false, critical: true },\n  { name: 'keyUsage', digitalSignature: true, keyEncipherment: true, critical: true },\n  { name: 'extKeyUsage', serverAuth: true, clientAuth: true },\n  { name: 'subjectAltName', altNames: [\n    { type: 2, value: commonName },\n    // For localhost, also includes: { type: 7, ip: '127.0.0.1' }\n  ]}\n]\n```\n\n### Elliptic Curve (EC) Keys\n\nBy default, selfsigned generates RSA keys. You can generate certificates using elliptic curve cryptography instead, which provides equivalent security with smaller key sizes and faster operations.\n\n```js\n// Generate EC certificate with P-256 curve (default)\nconst pems = await selfsigned.generate(null, { keyType: 'ec' });\n\n// Generate EC certificate with P-384 curve\nconst pems = await selfsigned.generate(null, { keyType: 'ec', curve: 'P-384' });\n\n// Generate EC certificate with P-521 curve and SHA-512\nconst pems = await selfsigned.generate(null, {\n  keyType: 'ec',\n  curve: 'P-521',\n  algorithm: 'sha512'\n});\n```\n\n**Supported curves:**\n- `P-256` (default) - 128-bit security, fastest\n- `P-384` - 192-bit security\n- `P-521` - 256-bit security, strongest\n\nEC keys work with all other options including `clientCertificate`, `passphrase`, `ca`, and `keyPair`:\n\n```js\n// EC certificate with encrypted private key\nconst pems = await selfsigned.generate(null, {\n  keyType: 'ec',\n  passphrase: 'secret'\n});\n\n// EC certificate with client certificate\nconst pems = await selfsigned.generate(null, {\n  keyType: 'ec',\n  clientCertificate: true\n});\n\n// Reuse existing EC key pair\nconst pems = await selfsigned.generate(null, {\n  keyType: 'ec',\n  curve: 'P-256',\n  keyPair: {\n    publicKey: existingPublicKey,\n    privateKey: existingPrivateKey\n  }\n});\n```\n\n### Using Your Own Keys\n\nYou can avoid key pair generation by specifying your own keys:\n\n```js\nconst pems = await selfsigned.generate(null, {\n  keyPair: {\n    publicKey: '-----BEGIN PUBLIC KEY-----...',\n    privateKey: '-----BEGIN PRIVATE KEY-----...'\n  }\n});\n```\n\n### Encrypting the Private Key\n\nYou can encrypt the private key with a passphrase using AES-256-CBC:\n\n```js\nconst pems = await selfsigned.generate(null, {\n  passphrase: 'my-secret-passphrase'\n});\n\n// The private key will be in encrypted PKCS#8 format:\n// -----BEGIN ENCRYPTED PRIVATE KEY-----\n// ...\n// -----END ENCRYPTED PRIVATE KEY-----\n```\n\nTo use the encrypted key, provide the passphrase:\n\n```js\nconst crypto = require('crypto');\n\n// Decrypt the key\nconst privateKey = crypto.createPrivateKey({\n  key: pems.private,\n  passphrase: 'my-secret-passphrase'\n});\n\n// Or use directly with HTTPS server\nconst https = require('https');\nhttps.createServer({\n  key: pems.private,\n  passphrase: 'my-secret-passphrase',\n  cert: pems.cert\n}, app).listen(443);\n```\n\n### Signing with a CA\n\nYou can generate certificates signed by an existing Certificate Authority instead of self-signed certificates. This is useful for development environments where you want browsers to trust your certificates.\n\n```js\nconst fs = require('fs');\nconst selfsigned = require('selfsigned');\n\nconst pems = await selfsigned.generate([\n  { name: 'commonName', value: 'localhost' }\n], {\n  algorithm: 'sha256',\n  ca: {\n    key: fs.readFileSync('/path/to/ca.key', 'utf8'),\n    cert: fs.readFileSync('/path/to/ca.crt', 'utf8')\n  }\n});\n```\n\nThe generated certificate will be signed by the provided CA and will include:\n- Subject Alternative Name (SAN) extension with DNS name matching the commonName\n- For `localhost`, an additional IP SAN for `127.0.0.1`\n- Key Usage: digitalSignature, keyEncipherment\n- Extended Key Usage: serverAuth, clientAuth\n\n#### Using with mkcert\n\n[mkcert](https://github.com/FiloSottile/mkcert) is a simple tool for making locally-trusted development certificates. Combining it with `selfsigned` provides an excellent developer experience:\n\n- **No certificate files to manage** - generate trusted certificates on-the-fly at server startup\n- **No git-ignored cert files** - nothing to store, share, or accidentally commit\n- **Browsers trust the certificates automatically** - no security warnings during development\n\n```js\nconst https = require('https');\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\nconst selfsigned = require('selfsigned');\n\n// Get mkcert's CA (requires: brew install mkcert && mkcert -install)\nconst caroot = execSync('mkcert -CAROOT', { encoding: 'utf8' }).trim();\n\nconst pems = await selfsigned.generate([\n  { name: 'commonName', value: 'localhost' }\n], {\n  algorithm: 'sha256',\n  ca: {\n    key: fs.readFileSync(path.join(caroot, 'rootCA-key.pem'), 'utf8'),\n    cert: fs.readFileSync(path.join(caroot, 'rootCA.pem'), 'utf8')\n  }\n});\n\n// Start server with browser-trusted certificate - no files written to disk\nhttps.createServer({ key: pems.private, cert: pems.cert }, app).listen(443);\n```\n\nSee [examples/https-server-mkcert.js](examples/https-server-mkcert.js) for a complete working example.\n\n## Attributes\n\nAttributes follow the X.509 standard:\n\n```js\nconst attrs = [\n  { name: 'commonName', value: 'example.org' },\n  { name: 'countryName', value: 'US' },\n  { shortName: 'ST', value: 'Virginia' },\n  { name: 'localityName', value: 'Blacksburg' },\n  { name: 'organizationName', value: 'Test' },\n  { shortName: 'OU', value: 'Test' }\n];\n```\n\n## Generate Client Certificates\n\nFor environments where servers require client certificates, you can generate client keys signed by the original (server) key:\n\n```js\nconst pems = await selfsigned.generate(null, { clientCertificate: true });\nconsole.log(pems);\n```\n\nOutput includes additional client certificate fields:\n\n```js\n{\n  private: '-----BEGIN PRIVATE KEY-----\\n...',\n  public: '-----BEGIN PUBLIC KEY-----\\n...',\n  cert: '-----BEGIN CERTIFICATE-----\\n...',\n  fingerprint: 'XX:XX:XX:...',\n  clientprivate: '-----BEGIN PRIVATE KEY-----\\n...',\n  clientpublic: '-----BEGIN PUBLIC KEY-----\\n...',\n  clientcert: '-----BEGIN CERTIFICATE-----\\n...'\n}\n```\n\n### Client Certificate Options\n\nThe `clientCertificate` option can be `true` for defaults, or an options object for full control:\n\n```js\nconst pems = await selfsigned.generate(null, {\n  clientCertificate: {\n    cn: 'jdoe',                              // common name (default: 'John Doe jdoe123')\n    keyType: 'rsa',                          // key type: 'rsa' or 'ec' (default: inherits from parent)\n    keySize: 4096,                           // key size in bits (default: 2048, RSA only)\n    curve: 'P-256',                          // elliptic curve (default: 'P-256', EC only)\n    algorithm: 'sha256',                     // signature algorithm (default: inherits from parent or 'sha1')\n    notBeforeDate: new Date(),               // validity start (default: now)\n    notAfterDate: new Date('2026-01-01')     // validity end (default: notBeforeDate + 1 year)\n  }\n});\n```\n\nSimple example with just a custom CN:\n\n```js\nconst pems = await selfsigned.generate(null, {\n  clientCertificate: { cn: 'FooBar' }\n});\n```\n\n## PKCS#7 Support\n\nPKCS#7 formatting is available through a separate module for better tree-shaking:\n\n```js\nconst selfsigned = require('selfsigned');\nconst { createPkcs7 } = require('selfsigned/pkcs7');\n\nconst pems = await selfsigned.generate(attrs);\nconst pkcs7 = createPkcs7(pems.cert);\nconsole.log(pkcs7); // PKCS#7 formatted certificate\n```\n\nYou can also create PKCS#7 for client certificates:\n\n```js\nconst pems = await selfsigned.generate(null, { clientCertificate: true });\nconst clientPkcs7 = createPkcs7(pems.clientcert);\n```\n\n## Migration from v4.x\n\nVersion 5.0 introduces breaking changes:\n\n### Breaking Changes\n\n1. **Async-only API**: The `generate()` function is now async and returns a Promise. Synchronous generation is no longer supported.\n2. **No callback support**: Callbacks have been removed. Use `async`/`await` or `.then()`.\n3. **Minimum Node.js version**: Now requires Node.js >= 15.6.0 (was >= 10).\n4. **Dependencies**: Replaced `node-forge` with `@peculiar/x509` and `pkijs` (66% smaller bundle size).\n5. **`days` option removed**: Use `notAfterDate` instead. Default validity is 365 days from `notBeforeDate`.\n\n### Migration Examples\n\n**Old (v4.x):**\n```js\n// Sync\nconst pems = selfsigned.generate(attrs, { days: 365 });\n\n// Callback\nselfsigned.generate(attrs, { days: 365 }, function(err, pems) {\n  if (err) throw err;\n  console.log(pems);\n});\n```\n\n**New (v5.x):**\n```js\n// Async/await (default 365 days validity)\nconst pems = await selfsigned.generate(attrs);\n\n// Custom validity with notAfterDate\nconst notAfter = new Date();\nnotAfter.setDate(notAfter.getDate() + 30); // 30 days\nconst pems = await selfsigned.generate(attrs, { notAfterDate: notAfter });\n\n// Or with .then()\nselfsigned.generate(attrs)\n  .then(pems => console.log(pems))\n  .catch(err => console.error(err));\n```\n\n## License\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) 2013 José F. Romaniello\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/selfsigned/-/selfsigned-5.5.0.tgz#4c9ab7c7c9f35f18fb6a9882c253eb0e6bd6557b",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/selfsigned/-/selfsigned-5.5.0.tgz",
    "hash": "4c9ab7c7c9f35f18fb6a9882c253eb0e6bd6557b",
    "integrity": "sha512-ftnu3TW4+3eBfLRFnDEkzGxSF/10BJBkaLJuBHZX0kiPS7bRdlpZGu6YGt4KngMkdTwJE6MbjavFpqHvqVt+Ew==",
    "registry": "npm",
    "packageName": "selfsigned",
    "cacheIntegrity": "sha512-ftnu3TW4+3eBfLRFnDEkzGxSF/10BJBkaLJuBHZX0kiPS7bRdlpZGu6YGt4KngMkdTwJE6MbjavFpqHvqVt+Ew== sha1-TJq3x8nzXxj7apiCwlPrDmvWVXs="
  },
  "registry": "npm",
  "hash": "4c9ab7c7c9f35f18fb6a9882c253eb0e6bd6557b"
}