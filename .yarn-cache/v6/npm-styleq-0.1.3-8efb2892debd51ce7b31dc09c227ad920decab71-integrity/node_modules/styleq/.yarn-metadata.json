{
  "manifest": {
    "version": "0.1.3",
    "name": "styleq",
    "main": "styleq.js",
    "module": "dist/styleq.js",
    "sideEffects": false,
    "license": "MIT",
    "description": "A quick JavaScript runtime for Atomic CSS compilers.",
    "repository": {
      "type": "git",
      "url": "https://github.com/necolas/styleq"
    },
    "author": {
      "name": "Nicolas Gallagher"
    },
    "files": [
      "dist",
      "*.js",
      "*.ts"
    ],
    "scripts": {
      "benchmark": "node test/benchmark.node.js",
      "build": "babel src --out-dir dist --config-file ./configs/.babelrc",
      "flow": "flow --flowconfig-name ./configs/.flowconfig",
      "jest": "jest ./test",
      "lint": "npm run lint:report -- --fix",
      "lint:report": "eslint src/**/*.js --config ./configs/.eslintrc",
      "prepare": "npm run test && npm run build",
      "prettier": "prettier --write \"**/*.js\" --ignore-path ./configs/.prettierignore",
      "prettier:report": "prettier --check \"**/*.js\" --ignore-path ./configs/.prettierignore",
      "test": "npm run flow && npm run prettier:report && npm run lint:report && npm run jest"
    },
    "devDependencies": {
      "@babel/cli": "^7.13.10",
      "@babel/core": "^7.15.5",
      "@babel/eslint-parser": "^7.15.8",
      "@babel/plugin-syntax-flow": "^7.12.13",
      "@babel/preset-env": "^7.15.6",
      "@babel/preset-flow": "^7.14.5",
      "@babel/types": "^7.15.6",
      "benchmark": "^2.1.4",
      "eslint": "^7.32.0",
      "eslint-config-prettier": "^7.2.0",
      "eslint-plugin-flowtype": "^7.0.0",
      "flow-bin": "^0.195.2",
      "jest": "^27.2.4",
      "prettier": "^2.4.1"
    },
    "jest": {
      "snapshotFormat": {
        "printBasicPrototype": false
      },
      "transform": {
        "\\.js$": [
          "babel-jest",
          {
            "configFile": "./configs/.babelrc"
          }
        ]
      }
    },
    "prettier": {
      "singleQuote": true
    },
    "_registry": "npm",
    "_loc": "/home/dev/api_maker/.yarn-cache/v6/npm-styleq-0.1.3-8efb2892debd51ce7b31dc09c227ad920decab71-integrity/node_modules/styleq/package.json",
    "readmeFilename": "README.md",
    "readme": "# styleQ &middot; [![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/necolas/styleq/blob/main/LICENSE) [![npm version](https://img.shields.io/npm/v/styleq.svg?style=flat)](https://www.npmjs.com/package/styleq) [![Build Status](https://github.com/necolas/styleq/workflows/tests/badge.svg)](https://github.com/necolas/styleq/actions) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/necolas/styleq/blob/master/.github/CONTRIBUTING.md)\n\n**styleQ** is a quick, small JavaScript runtime for merging the HTML class names produced by CSS compilers.\n\n* High performance merging for initial render.\n* Built-in memoization for updates.\n* Merges static and dynamic styles.\n* Supports various CSS compiler designs.\n* 0.7 KB gzipped runtime.\n\n## Use\n\nInstall:\n\n```\nnpm install styleq\n```\n\nImport:\n\n```js\nimport { styleq } from 'styleq';\n```\n\n## API\n\n### styleq(...styles)\n\nMerges style objects and produces a DOM `className` string and inline `style` object (camelCase property names).\n\n```js\nconst [ className, inlineStyle ] = styleq(styles.root, { opacity });\n```\n\nThe `styleq` function efficiently merges deeply nested arrays of both extracted and inline style objects.\n\n* Compiled styles must set the `$$css` property to `true`.\n* Any style object without the `$$css` property is treated as an **inline style**.\n* Compiled styles must be static for best performance.\n* Compiled style object keys do not need to match CSS property names; any string is allowed.\n* Compiled style object values must be an **HTML class string**.\n\n```js\n/* Generated output */\n\nconst styles = {\n  root: {\n    // Needed by the runtime\n    $$css: true,\n    // Debug classes\n    'debug::file:styles.root': 'debug::file:styles.root',\n    // Atomic CSS classes\n    display: 'display-flex-class',\n    alignItems: 'alignItems-center-class'\n  }\n};\n\nconst [ className, inlineStyle ] = styleq(styles.root, props.style);\n```\n\n### styleq.factory(options) => styleq\n\nA factory for creating custom merging functions, tailored to the design of specific compilers.\n\n```js\nconst compilerStyleq = styleq.factory(options);\n```\n\nOptions are used to configure the merging function.\n\n```js\ntype Options = {\n  // control memoization\n  disableCache: boolean = false;\n  // control className/style merge strategy\n  disableMix: boolean = false;\n  // transform individual styles at runtime before merging\n  transform: ?(style) => compiledStyle;\n}\n```\n\n#### `disableCache`\n\n**Memoization is enabled by default**. This option can be used to disable it. Memoization relies on a tree of WeakMaps keyed on static compiled styles. This allows the runtime to efficiently store chunks of merged styles, making re-computation very cheap. However, checking the WeakMap for memoized data when there is none significantly adds to the cost of initially computing the result. Therefore, if initial computations need to be as fast as possible (e.g., your use case involves few repeat merges), memoization should be disabled.\n\n```js\nconst styleqNoCache = styleq.factory({ disableCache: true });\n```\n\n#### `disableMix`\n\n**Inline styles are merged together with static styles by default**, but can be merged independently if preferred. Both static and inline styles can be passed to `styleq` for merging. By default, the properties defined by static and inline styles are merged together. The performance of this option is still excellent, but merging with inline styles often means memoization cannot be used as effectively. In certain circumstances, this merging strategy can result in better performance, as the deduplication of styles can reduce the number of CSS rules applied to the element (which improves browser layout times).\n\nIf mixing is diabled, the static and inline styles will be treated as values for different attributes: either `className` OR `style` respectively. If an inline style sets a property that is later set by a static style, *both* the static class name and dynamic style property will be set. In practice this means that inline style declarations override those of static styles, whatever their position in the styles array passed to `styleq`. Therefore, memoization of class name merges is not changed by inline styles, and so provides the best general performance.\n\n```js\nconst styleqNoMix = styleq.factory({ disableMix: true });\n```\n\n#### `transform`\n\n**Styles can be transformed before merging** by using the `transform` function. The runtime loop is extremely performance sensitive as class name merges can happen 1000s of times during a screen render, whether on the server or client. The `transform` function is used to change style objects before styleQ merges them. For example, if a compiler needs runtime information before selecting a compiled style.\n\n```js\n// compiler/useStyleq\nimport { styleq } from 'styleq';\nimport { localizeExtractedStyle } from './localizeExtractedStyle';\nimport { useLocaleContext } from './useLocaleContext'\nimport { useMemo } from 'react';\n\nexport function useStyleq(styles) {\n  // Runtime context provides subtree writing direction\n  const { direction } = useLocaleContext();\n  const isRTL = direction === 'rtl';\n  // Create a custom styleq for localization transform\n  const styleqWithPolyfills = useMemo(\n    () => styleq.factory({\n      transform(style) {\n        // Memoize results in the transform\n        return localizeExtractedStyle(style, isRTL);\n      }\n    }),\n    [ isRTL ]\n  );\n  const styleProps = styleqWithPolyfills(styles);\n  // Add vendor prefixes to inline styles\n  if (styleProps[1]) {\n    styleProps[1] = prefixAll(styleProps[1]);\n  }\n  return styleProps;\n}\n```\n\nWARNING: Transforming compiled styles to support runtime dynamism is possible without negatively effecting performance, however, transforms must be done carefully to avoid creating merge operations that cannot be efficiently memoized. `WeakMap` is recommended for memoizing the result of transforms, so that static objects are passed to styleq.\n\n## Notes for compiler authors\n\nCSS compilers implementing different styling models can all target styleQ to deliver excellent runtime performance. styleQ can be used at build time and runtime (for server and client) to generate `className` and `style` values.\n\nExamples of how various compiler features and designs can supported with styleQ are discussed below.\n\n* [Supporting zero-conflict styles](#supporting-zero-conflict-styles)\n* [Supporting arbitrary selectors](#supporting-arbitrary-selectors)\n* [Supporting high-performance layouts](#supporting-high-performance-layouts)\n* [Supporting high-performance inline styles](#supporting-high-performance-inline-styles)\n* [Supporting themes](#supporting-themes)\n* [Polyfilling logical properties and values](#polyfilling-logical-properties-and-values)\n* [Implementing utility styles](#implementing-utility-styles)\n\n### Supporting zero-conflict styles\n\nZero-conflict styles provide developers with guarantees that component style is encapsulated and not implicitly altered by styles defined by other components. A compiler designed around zero-conflict styles will generally output \"atomic CSS\" and produce smaller CSS style sheets that avoid all specificity and source order conflicts.\n\nTypically, a zero-conflict design involves excluding support for descendant selectors (i.e., any selector that targets an element other than the element receiving the class name). And shortform properties are either disallowed, restricted, or automatically expanded to longform properties. If pseudo-classes (e.g., `:focus`) are supported, the compiler must guarantee the order of precedence between pseudo-classes in the CSS style sheet (e.g., `:focus` rules appear before `:active` rules). If Media Queries are supported, they too must be carefully ordered.\n\nInput:\n\n```js\nimport * as compiler from 'compiler';\n\nconst styles = compiler.create({\n  root: {\n    margin: 10,\n    opacity: 0.7,\n    ':focus': {\n      opacity: 0.8\n    },\n    ':active': {\n      opacity: 1.0\n    }\n  }\n});\n```\n\nOutput:\n\n```js\ninsertOrExtract('.margin-left-10 { margin-left:10px; }', 0);\ninsertOrExtract('.margin-top-10 { margin-top:10px; }', 0);\ninsertOrExtract('.margin-right-10 { margin-right:10px; }', 0);\ninsertOrExtract('.margin-bottom-10 { margin-bottom:10px; }', 0);\ninsertOrExtract('.opacity-07 { opacity:0.7; }', 0);\n// Pseudo-class insertion order is after class selector rules\ninsertOrExtract('.focus-opacity-08:focus { opacity:0.8; }', 1.0);\ninsertOrExtract('.active-opacity-1:active { opacity:1; }', 1.1);\n\nconst styles = {\n  root: {\n    $$css: true,\n    marginLeft: 'margin-left-10',\n    marginTop: 'margin-top-10',\n    marginRight: 'margin-right-10',\n    marginBottom: 'margin-bottom-10',\n    opacity: 'opacity-07',\n    __focus$opacity: 'focus-opacity-08',\n    __active$opacity: 'active-opacity-1'\n  }\n};\n```\n\n### Supporting arbitrary selectors\n\nThe runtime can be used by compilers that support arbitrary selectors, e.g., by concatenating (hashing, etc.) the selector string and property to create a unique key for that selector-property combination. (Note that supporting arbitrary CSS selectors trades flexibility for zero-conflict styles.)\n\nInput:\n\n```js\nimport * as compiler from 'compiler';\n\nconst styles = compiler.create({\n  root: {\n    ':focus a[data-prop]': {\n      opacity: 1\n    }\n  }\n});\n```\n\nOutput:\n\n```js\ninsertOrExtract('.xjrodmsp-opacity-1:focus a[data-prop] { opacity:1.0; }');\n\nconst styles = {\n  root: {\n    $$css: true,\n    '__xjrodmsp-opacity-1': 'xjrodmsp-opacity-1'\n  }\n};\n```\n\n### Supporting high-performance layouts\n\nAtomic CSS has tradeoffs. Once an element has many HTML class names each pointing to different CSS rules, browser layout times slow down. In some cases, compilers may choose to flatten multiple declarations into \"traditional\" CSS. For example, a component library may optimize the \"reset\" styles for its core components by flattening those styles, and then inserting those rules into the CSS style sheet before all the atomic CSS. That way atomic CSS will always override the reset rules, and the layout performance of the core components will be significantly improved.\n\nInput:\n\n```jsx\nimport { createResetStyle } from 'compiler';\n\nfunction View(props) {\n  return (\n    <div {...props} css={reset, props.css} />\n  );\n}\n\nconst reset = createResetStyle({\n  display: 'flex',\n  alignItems: 'stretch',\n  flexDirection: 'row',\n  ...\n});\n```\n\nOutput:\n\n```jsx\nimport { styleq } from 'compiler/styleq';\n\n// Compiler inserts Reset CSS rules before Atomic CSS rules.\ninsertOrExtract('.reset-<hash> { display:flex; align-items:stretch; flex-direction:row', 0);\n\nfunction View(props) {\n  const [ className, inlineStyle ] = styleq(reset, props.css);\n  return (\n    <div {...props} className={className} style={inlineStyle} />\n  );\n}\n\nconst reset = {\n  $$css: true,\n  // Compiler decides that only one reset is allowed per element.\n  // Each reset rule created is set to the '__reset' key.\n  __reset: 'reset-<hash>',\n};\n```\n\n### Supporting high-performance inline styles\n\nA compiler may provide a single API for defining static and dynamic values, and  maximize the number of compiled styles by replacing dynamic values with unique CSS custom properties that are then set by inline styles. This compiler design decouples static and inline property merges, and makes the best use of runtime memoization.\n\nInput:\n\n```jsx\n// @jsx createElement\nimport { createElement } from 'compiler';\n\nfunction Fade(props) {\n  return (\n    <div\n      {...props}\n      css={{\n        // static value\n        backgroundColor: 'blue',\n        // dynamic value\n        opacity: props.opacity,\n        ...props.css\n      }}\n    />\n  );\n}\n```\n\nOutput:\n\n```jsx\n// Custom styleq with mixing disabled\nimport { customStyleq } from 'compiler/customStyleq';\n\n// The opacity value is a unique CSS custom property\ninsertOrExtract('.backgroundColor-blue { background-color:blue; }');\ninsertOrExtract('.opacity-var-xyz { opacity:var(--opacity-xyz); }');\n\n// A compiled style is generated, including the 'opacity' property\nconst compiledStyle = {\n  $$css: true,\n  backgroundColor: 'backgroundColor-blue',\n  opacity: 'opacity-var-xyz'\n};\n\nfunction Fade(props) {\n  const [ className, style ] = customStyleq(\n    // The dynamic value is set to the custom property.\n    // With static/dynamic mixing disabled, the position of the inline style\n    // is irrelevant. However, with mixing enabled, the best performance is\n    // achieved by placing inline styles earlier in the queue.\n    { '--opacity-xyz': props.opacity },\n    compiledStyle,\n    props.css\n  );\n\n  return (\n    <div\n      {...props}\n      className={className}\n      style={style}\n    />\n  );\n}\n```\n\n\n### Supporting themes\n\nCompilers implementing themes via CSS custom properties should avoid creating atomic CSS rules for each theme property. As mentioned above, this can slow down browser layout and flattening theme styles into a single rule is preferred. Theme classes can be deduplicated by using the same key for all themes in the generated style object.\n\nInput:\n\n```js\nimport * as compiler from 'compiler';\n\nconst [themeVars, themeStyle] = compiler.createDefaultTheme({\n  color: {\n    primary: '#fff',\n    secondary: '#f5d90a'\n    ...\n  },\n  space: {},\n  size: {}\n});\n\nconst className = compiler.merge(themeStyle, props.style);\n```\n\nOutput:\n\n```js\nimport { styleq } from 'compiler/styleq';\n\ninsertOrExtract(\n  ':root, .theme-default { --theme-default-color-primary:#fff; --theme-default-color-secondary:#f5d90a; }'\n);\n\nconst themeVars = {\n  color: {\n    primary: 'var(--theme-default-color-primary)',\n    secondary: 'var(--theme-default-color-secondary)'\n    ...\n  }\n};\n\nconst themeStyle = {\n  $$css: true,\n  __theme: 'theme-default'\n};\n\nconst [ className ] = styleq(themeStyle, props.style);\n```\n\n### Polyfilling logical properties and values\n\nA compiler might provide a polyfill for [CSS logical properties and values](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties). Using the `transform` option is one way to implement this functionality.\n\nInput:\n\n```js\nimport { StyleSheet } from 'compiler';\n\nfunction Box() {\n  return <div style={styles.root} />\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    float: 'inline-start',\n  }\n});\n```\n\nOutput:\n\n```js\n// See the 'useStyleq' example in the API docs above\nimport { useStyleq } from 'compiler/useStyleq';\n\ninsertOrExtract('.float-left { float:left; }');\ninsertOrExtract('.float-right { float:right; }');\n\nfunction Box() {\n  const [ className ] = useStyleq(styles.view, styles.root);\n  return <div className={className} />\n}\n\nconst styles = {\n  root: {\n    $$css: true,\n    // Compiler defines a custom key to mark this style object\n    // for processessing by the localized transform.\n    $$css$localize: true,\n    // [ LTR, RTL ]\n    float: [ 'float-left', 'float-right' ]\n  }\n}\n```\n\nIn this case, `useStyleq` is a function defined by the compiler which transforms `$$css` styles into the correct class name for a given writing direction. An example of this transform can be seen in the [`localizeStyle`](./src/transform-localize-style.js) module. Note how care is taken to memoize the transform so that the same result is always used in merges.\n\n### Implementing utility styles\n\nCompilers that produce \"utility\" CSS rules can use styleQ to dedupe utilities across categories, i.e., higher-level styling abstractions such as \"size\", \"spacing\", \"color scheme\", etc. The keys of extracted styles can match the utility categories.\n\nInput:\n\n```js\nimport { oocss } from 'compiler';\n\nconst View = (props) => (\n  // This compiler targets strings for named \"utilities\"\n  <div {...props} className={oocss('cs-1 p-1 s-1', props.css)} />\n);\n\nconst StyledView = (props) => (\n  <View {...props} css={oocss('cs-2 p-2')} />\n);\n```\n\nOutput:\n\n```js\nimport { styleq } from 'styleq';\n\ninsertOrExtract('.cs-1 { --primary-color:#000; --secondary-color:#eee }', 2);\ninsertOrExtract('.cs-2 { --primary-color:#fff; --secondary-color:#333 }', 2);\ninsertOrExtract('.p-1 { padding:10px }', 0);\ninsertOrExtract('.p-2 { padding:20px }', 0);\ninsertOrExtract('.s-1 { height:100px; width:100px }', 1);\n\n// Each utility class is categorized. For example, only a single 'colorScheme'\n// rule will be applied to each element.\nconst oocss1 = {\n  $$css: true,\n  __cs: 'cs-1',\n  __p: 'p-1',\n  __s: 's-1'\n};\n\nconst View = (props) => (\n  <div {...props} className={styleq(oocss1, props.css)} />\n);\n\nconst oocss2 = {\n  $$css: true,\n  __cs: 'cs-2',\n  __p: 'p-2'\n}\n\nconst StyledView = (props) => (\n  <View {...props} css={oocss2} />\n);\n```\n\n## License\n\nstyleq is [MIT licensed](./LICENSE).\n",
    "licenseText": "MIT License\n\nCopyright (c) Nicolas Gallagher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/styleq/-/styleq-0.1.3.tgz#8efb2892debd51ce7b31dc09c227ad920decab71",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/styleq/-/styleq-0.1.3.tgz",
    "hash": "8efb2892debd51ce7b31dc09c227ad920decab71",
    "integrity": "sha512-3ZUifmCDCQanjeej1f6kyl/BeP/Vae5EYkQ9iJfUm/QwZvlgnZzyflqAsAWYURdtea8Vkvswu2GrC57h3qffcA==",
    "registry": "npm",
    "packageName": "styleq",
    "cacheIntegrity": "sha512-3ZUifmCDCQanjeej1f6kyl/BeP/Vae5EYkQ9iJfUm/QwZvlgnZzyflqAsAWYURdtea8Vkvswu2GrC57h3qffcA== sha1-jvsokt69Uc57MdwJwietkg3sq3E="
  },
  "registry": "npm",
  "hash": "8efb2892debd51ce7b31dc09c227ad920decab71"
}