{
  "manifest": {
    "name": "tsyringe",
    "version": "4.10.0",
    "description": "Lightweight dependency injection container for JavaScript/TypeScript",
    "main": "dist/cjs/index.js",
    "module": "./dist/esm5/index.js",
    "es2015": "./dist/esm2015/index.js",
    "typings": "./dist/typings/index.d.ts",
    "scripts": {
      "build": "yarn clean && yarn build:cjs && yarn build:es5 && yarn build:es2015 && yarn build:types",
      "build:cjs": "tsc",
      "build:es5": "tsc -p ./typescript/tsconfig.esm5.json",
      "build:es2015": "tsc -p ./typescript/tsconfig.esm2015.json",
      "build:types": "tsc -p ./typescript/tsconfig.types.json",
      "clean": "rimraf ./dist",
      "test": "yarn lint && jest --config test/jest.config.js",
      "test:inspect": "yarn lint && node --inspect-brk ./node_modules/jest/bin/jest.js --runInBand --config test/jest.config.js",
      "test:coverage": "jest --config test/jest.config.js --coverage",
      "lint": "eslint --ext \".js,.jsx,.ts,.tsx\" \"./src\"",
      "lint:fix": "eslint --fix --ext \".js,.jsx,.ts,.tsx\" \"./src\""
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/Microsoft/tsyringe.git"
    },
    "keywords": [
      "dependency injection",
      "dependency",
      "injection",
      "ioc",
      "container",
      "javascript",
      "typescript"
    ],
    "engines": {
      "node": ">= 6.0.0"
    },
    "author": {
      "name": "Steven Hobson-Campbell"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/Microsoft/tsyringe/issues"
    },
    "homepage": "https://github.com/Microsoft/tsyringe#readme",
    "dependencies": {
      "tslib": "^1.9.3"
    },
    "devDependencies": {
      "@types/jest": "^24.0.21",
      "@types/node": "^8.10.16",
      "@typescript-eslint/eslint-plugin": "^2.6.0",
      "@typescript-eslint/parser": "^2.6.0",
      "eslint": "^6.6.0",
      "eslint-config-prettier": "^6.5.0",
      "eslint-plugin-prettier": "^3.1.1",
      "husky": "^3.0.0",
      "jest": "^24.7.1",
      "prettier": "1.18.2",
      "reflect-metadata": "^0.1.12",
      "rimraf": "^3.0.0",
      "ts-jest": "^24.0.2",
      "typescript": "^3.1.6"
    },
    "_registry": "npm",
    "_loc": "/home/dev/api_maker/.yarn-cache/v6/npm-tsyringe-4.10.0-d0c95815d584464214060285eaaadd94aa03299c-integrity/node_modules/tsyringe/package.json",
    "readmeFilename": "README.md",
    "readme": "[![Travis](https://img.shields.io/travis/Microsoft/tsyringe.svg)](https://travis-ci.org/Microsoft/tsyringe/)\n[![npm](https://img.shields.io/npm/v/tsyringe.svg)](https://www.npmjs.com/package/tsyringe)\n[![npm](https://img.shields.io/npm/dt/tsyringe.svg)](https://www.npmjs.com/package/tsyringe)\n\n# TSyringe\n\nA lightweight dependency injection container for TypeScript/JavaScript for\nconstructor injection.\n\n<!-- TOC depthFrom:1 depthTo:3 -->\n\n- [TSyringe](#tsyringe)\n  - [Installation](#installation)\n- [API](#api)\n  - [Decorators](#decorators)\n    - [injectable()](#injectable)\n    - [singleton()](#singleton)\n    - [autoInjectable()](#autoinjectable)\n    - [inject()](#inject)\n    - [injectAll()](#injectall)\n    - [injectWithTransform()](#injectWithTransform)\n    - [injectAllWithTransform()](#injectAllWithTransform)\n    - [scoped()](#scoped)\n  - [Container](#container)\n    - [Injection Token](#injection-token)\n    - [Providers](#providers)\n    - [Register](#register)\n    - [Registry](#registry)\n    - [Resolution](#resolution)\n    - [IsRegistered](#isregistered)\n    - [Interception](#interception)\n    - [Child Containers](#child-containers)\n    - [Clearing Instances](#clearing-instances)\n- [Circular dependencies](#circular-dependencies)\n  - [The `delay` helper function](#the-delay-helper-function)\n  - [Interfaces and circular dependencies](#interfaces-and-circular-dependencies)\n- [Disposable instances](#disposable-instances)\n- [Full examples](#full-examples)\n  - [Example without interfaces](#example-without-interfaces)\n  - [Example with interfaces](#example-with-interfaces)\n  - [Injecting primitive values (Named injection)](#injecting-primitive-values-named-injection)\n- [Non goals](#non-goals)\n- [Contributing](#contributing)\n\n<!-- /TOC -->\n\n## Installation\n\nInstall by `npm`\n\n```sh\nnpm install --save tsyringe\n```\n\n**or** install with `yarn` (this project is developed using `yarn`)\n\n```sh\nyarn add tsyringe\n```\n\nModify your `tsconfig.json` to include the following settings\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\nAdd a polyfill for the Reflect API (examples below use reflect-metadata). You can use:\n\n- [reflect-metadata](https://www.npmjs.com/package/reflect-metadata)\n- [core-js (core-js/es7/reflect)](https://www.npmjs.com/package/core-js)\n- [reflection](https://www.npmjs.com/package/@abraham/reflection)\n\nThe Reflect polyfill import should only be added once, and before DI is used:\n\n```typescript\n// main.ts\nimport \"reflect-metadata\";\n\n// Your code here...\n```\n\n### Babel\n\nIf you're using Babel (e.g. using React Native), you will need to configure it to emit TypeScript metadata.\n\nFirst get the Babel plugin\n\n#### Yarn\n\n```\nyarn add --dev babel-plugin-transform-typescript-metadata\n```\n\n#### npm\n\n```\nnpm install --save-dev babel-plugin-transform-typescript-metadata\n```\n\nThen add it to your Babel config\n\n```\nplugins: [\n            'babel-plugin-transform-typescript-metadata',\n            /* ...the rest of your config... */\n         ]\n```\n\n# API\n\nTSyringe performs [Constructor Injection](https://en.wikipedia.org/wiki/Dependency_injection#Constructor_injection)\non the constructors of decorated classes.\n\n## Decorators\n\n### injectable()\n\nClass decorator factory that allows the class' dependencies to be injected at\nruntime. TSyringe relies on several decorators in order to collect metadata about classes\nto be instantiated.\n\n#### Usage\n\n```typescript\nimport {injectable} from \"tsyringe\";\n\n@injectable()\nclass Foo {\n  constructor(private database: Database) {}\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst instance = container.resolve(Foo);\n```\n\n### singleton()\n\nClass decorator factory that registers the class as a singleton within the\nglobal container.\n\n#### Usage\n\n```typescript\nimport {singleton} from \"tsyringe\";\n\n@singleton()\nclass Foo {\n  constructor() {}\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst instance = container.resolve(Foo);\n```\n\n### autoInjectable()\n\nClass decorator factory that replaces the decorated class' constructor with\na parameterless constructor that has dependencies auto-resolved.\n\n**Note** Resolution is performed using the global container.\n\n#### Usage\n\n```typescript\nimport {autoInjectable} from \"tsyringe\";\n\n@autoInjectable()\nclass Foo {\n  constructor(private database?: Database) {}\n}\n\n// some other file\nimport {Foo} from \"./foo\";\n\nconst instance = new Foo();\n```\n\nNotice how in order to allow the use of the empty constructor `new Foo()`, we\nneed to make the parameters optional, e.g. `database?: Database`.\n\n### inject()\n\nParameter decorator factory that allows for interface and other non-class\ninformation to be stored in the constructor's metadata.\n\n#### Usage\n\n```typescript\nimport {injectable, inject} from \"tsyringe\";\n\ninterface Database {\n  // ...\n}\n\n@injectable()\nclass Foo {\n  constructor(@inject(\"Database\") private database?: Database) {}\n}\n```\n\n#### Optional\nBy default, `@inject()` throws an exception if no registration is found. If you want to have `undefined` injected when the registration isn't found, you can pass this options `{ isOptional: true }` as the second parameter:\n\n```typescript\nimport {injectable, injectAll} from \"tsyringe\";\n\n@injectable()\nclass Foo {\n  constructor(@inject(\"Database\", { isOptional: true }) private database?: Database) {}\n}\n```\n\n### injectAll()\n\nParameter decorator for array parameters where the array contents will come from the container.\nIt will inject an array using the specified injection token to resolve the values.\n\n#### Usage\n\n```typescript\nimport {injectable, injectAll} from \"tsyringe\";\n\n@injectable()\nclass Foo {}\n\n@injectable()\nclass Bar {\n  constructor(@injectAll(Foo) fooArray: Foo[]) {\n    // ...\n  }\n}\n```\n\n#### Optional\nBy default, `@injectAll()` throws an exception if no registrations were found. If you want to return an empty array, you can pass this options `{ isOptional: true }` as the second parameter:\n\n```typescript\nimport {injectable, injectAll} from \"tsyringe\";\n\n@injectable()\nclass Bar {\n  constructor(@injectAll(Foo, { isOptional: true }) fooArray: Foo[]) {\n    // ...\n  }\n}\n```\n\n### injectWithTransform()\n\nParameter decorator which allows for a transformer object to take an action on the resolved object\nbefore returning the result.\n\n```typescript\nclass FeatureFlags {\n  public getFlagValue(flagName: string): boolean {\n    // ...\n  }\n}\n\nclass Foo() {}\n\nclass FeatureFlagsTransformer implements Transform<FeatureFlags, boolean> {\n  public transform(flags: FeatureFlags, flag: string) {\n    return flags.getFlagValue(flag);\n  }\n}\n\n@injectable()\nclass MyComponent(foo: Foo, @injectWithTransform(FeatureFlags, FeatureFlagsTransformer, \"IsBlahEnabled\") blahEnabled: boolean){\n  // ...\n}\n```\n\n### injectAllWithTransform()\n\nThis parameter decorator allows for array contents to be passed through a transformer. The transformer can return any type, so this\ncan be used to map or fold an array.\n\n```typescript\n@injectable()\nclass Foo {\n  public value;\n}\n\nclass FooTransform implements Transform<Foo[], string[]>{\n  public transform(foos: Foo[]): string[]{\n    return foos.map(f => f.value));\n  }\n}\n\n@injectable()\nclass Bar {\n  constructor(@injectAllWithTransform(Foo, FooTransform) stringArray: string[]) {\n    // ...\n  }\n}\n```\n\n### scoped()\n\nClass decorator factory that registers the class as a scoped dependency within the global container.\n\n#### Available scopes\n\n- Transient\n  - The **default** registration scope, a new instance will be created with each resolve\n- Singleton\n  - Each resolve will return the same instance (including resolves from child containers)\n- ResolutionScoped\n  - The same instance will be resolved for each resolution of this dependency during a single\n    resolution chain\n- ContainerScoped\n  - The dependency container will return the same instance each time a resolution for this dependency\n    is requested. This is similar to being a singleton, however if a child container is made, that child\n    container will resolve an instance unique to it.\n\n#### Usage\n\n```typescript\n@scoped(Lifecycle.ContainerScoped)\nclass Foo {}\n```\n\n## Container\n\nThe general principle behind [Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control) (IoC) containers\nis you give the container a _token_, and in exchange you get an instance/value. Our container automatically figures out the tokens most of the time, with 2 major exceptions, interfaces and non-class types, which require the `@inject()` decorator to be used on the constructor parameter to be injected (see above).\n\nIn order for your decorated classes to be used, they need to be registered with the container. Registrations take the\nform of a Token/Provider pair, so we need to take a brief diversion to discuss tokens and providers.\n\n### Injection Token\n\nA token may be either a string, a symbol, a class constructor, or a instance of [`DelayedConstructor`](#circular-dependencies).\n\n```typescript\ntype InjectionToken<T = any> =\n  | constructor<T>\n  | DelayedConstructor<T>\n  | string\n  | symbol;\n```\n\n### Providers\n\nOur container has the notion of a _provider_. A provider is registered with the DI\ncontainer and provides the container the information\nneeded to resolve an instance for a given token. In our implementation, we have the following 4\nprovider types:\n\n#### Class Provider\n\n```TypeScript\n{\n  token: InjectionToken<T>;\n  useClass: constructor<T>;\n}\n```\n\nThis provider is used to resolve classes by their constructor. When registering a class provider\nyou can simply use the constructor itself, unless of course you're making an alias (a\nclass provider where the token isn't the class itself).\n\n#### Value Provider\n\n```TypeScript\n{\n  token: InjectionToken<T>;\n  useValue: T\n}\n```\n\nThis provider is used to resolve a token to a given value. This is useful for registering\nconstants, or things that have a already been instantiated in a particular way.\n\n#### Factory provider\n\n```TypeScript\n{\n  token: InjectionToken<T>;\n  useFactory: FactoryFunction<T>;\n}\n```\n\nThis provider is used to resolve a token using a given factory. The factory has full access\nto the dependency container.\n\nWe have provided 2 factories for you to use, though any function that matches the `FactoryFunction<T>` signature\ncan be used as a factory:\n\n```typescript\ntype FactoryFunction<T> = (dependencyContainer: DependencyContainer) => T;\n```\n\n##### instanceCachingFactory\n\nThis factory is used to lazy construct an object and cache result, returning the single instance for each subsequent\nresolution. This is very similar to `@singleton()`\n\n```typescript\nimport {instanceCachingFactory} from \"tsyringe\";\n\n{\n  token: \"SingletonFoo\";\n  useFactory: instanceCachingFactory<Foo>(c => c.resolve(Foo));\n}\n```\n\n##### instancePerContainerCachingFactory\n\nThis factory is used to lazy construct an object and cache result per `DependencyContainer`, returning the single instance for each subsequent\nresolution from a single container. This is very similar to `@scoped(Lifecycle.ContainerScoped)`\n\n```typescript\nimport {instancePerContainerCachingFactory} from \"tsyringe\";\n\n{\n  token: \"ContainerScopedFoo\";\n  useFactory: instancePerContainerCachingFactory<Foo>(c => c.resolve(Foo));\n}\n```\n\n##### predicateAwareClassFactory\n\nThis factory is used to provide conditional behavior upon resolution. It caches the result by default, but\nhas an optional parameter to resolve fresh each time.\n\n```typescript\nimport {predicateAwareClassFactory} from \"tsyringe\";\n\n{\n  token: \"FooHttp\",\n  useFactory: predicateAwareClassFactory<Foo>(\n    c => c.resolve(Bar).useHttps, // Predicate for evaluation\n    FooHttps, // A FooHttps will be resolved from the container if predicate is true\n    FooHttp // A FooHttp will be resolved if predicate is false\n  );\n}\n```\n\n#### Token Provider\n\n```TypeScript\n{\n  token: InjectionToken<T>;\n  useToken: InjectionToken<T>;\n}\n```\n\nThis provider can be thought of as a redirect or an alias, it simply states that given token _x_,\nresolve using token _y_.\n\n### Register\n\nThe normal way to achieve this is to add `DependencyContainer.register()` statements somewhere\nin your program some time before your first decorated class is instantiated.\n\n```typescript\ncontainer.register<Foo>(Foo, {useClass: Foo});\ncontainer.register<Bar>(Bar, {useValue: new Bar()});\ncontainer.register<Baz>(\"MyBaz\", {useValue: new Baz()});\n```\n\n#### Registration options\n\nAs an optional parameter to `.register()` you may provide [`RegistrationOptions`](./src/types/registration-options.ts)\nwhich customize how the registration behaves. See the linked source code for up to date documentation\non available options.\n\n### Registry\n\nYou can also mark up any class with the `@registry()` decorator to have the given providers registered\nupon importing the marked up class. `@registry()` takes an array of providers like so:\n\n```TypeScript\n@registry([\n  { token: Foobar, useClass: Foobar },\n  { token: \"theirClass\", useFactory: (c) => {\n       return new TheirClass( \"arg\" )\n    },\n  }\n])\nclass MyClass {}\n```\n\nThis is useful when you want to [register multiple classes for the same token](#register).\nYou can also use it to register and declare objects that wouldn't be imported by anything else,\nsuch as more classes annotated with `@registry` or that are otherwise responsible for registering objects.\nLastly you might choose to use this to register 3rd party instances instead of the `container.register(...)` method.\nnote: if you want this class to be `@injectable` you must put the decorator before `@registry`, this annotation is not\nrequired though.\n\n### Resolution\n\nResolution is the process of exchanging a token for an instance. Our container will recursively fulfill the\ndependencies of the token being resolved in order to return a fully constructed object.\n\nThe typical way that an object is resolved is from the container using `resolve()`.\n\n```typescript\nconst myFoo = container.resolve(Foo);\nconst myBar = container.resolve<Bar>(\"Bar\");\n```\n\nYou can also resolve all instances registered against a given token with `resolveAll()`.\n\n```typescript\ninterface Bar {}\n\n@injectable()\nclass Foo implements Bar {}\n@injectable()\nclass Baz implements Bar {}\n\n@registry([\n  // registry is optional, all you need is to use the same token when registering\n  {token: \"Bar\", useToken: Foo}, // can be any provider\n  {token: \"Bar\", useToken: Baz}\n])\nclass MyRegistry {}\n\nconst myBars = container.resolveAll<Bar>(\"Bar\"); // myBars type is Bar[]\n```\n\nYou can also add one or more `InjectionToken` to the registration of your class directly in the `@injectable()` decorator:\n\n```typescript\ninterface Bar {}\n\n@injectable({token: \"Bar\"})\nclass Foo implements Bar {}\n@injectable({token: [\"Bar\", \"Bar2\"]})\nclass Baz implements Bar {}\n\nclass MyRegistry {}\n\nconst myBars = container.resolveAll<Bar>(\"Bar\"); // myBars type is Bar[], contains 2 instances\nconst myBars2 = container.resolveAll<Bar>(\"Bar2\"); // myBars2 type is Bar[], contains 1 instance\n```\n\n### IsRegistered\nYou can check if a token is registered in the container using `isRegistered()`.\n\n```typescript\nconst isRegistered = container.isRegistered(\"Bar\"); // true\n```\n\nIf you have a childContainer and want to recursively check if a token is registered in the parent container, you can pass `true` as a second parameter of `isRegistered()`.\n\n```typescript\nclass Bar {}\n\ncontainer.register(Bar, {useClass: Bar});\n\nconst childContainer = container.createChildContainer();\nchildContainer.isRegistered(Bar); // false\nchildContainer.isRegistered(Bar, true); // true\n```\n\n### Interception\n\nInterception allows you to register a callback that will be called before or after the resolution of a specific token.\nThis callback can be registered to execute only once (to perform initialization, for example),\non each resolution to do logging, for example.\n\n`beforeResolution` is used to take an action before an object is resolved.\n\n```typescript\nclass Bar {}\n\ncontainer.beforeResolution(\n  Bar,\n  // Callback signature is (token: InjectionToken<T>, resolutionType: ResolutionType) => void\n  () => {\n    console.log(\"Bar is about to be resolved!\");\n  },\n  {frequency: \"Always\"}\n);\n```\n\n`afterResolution` is used to take an action after the object has been resolved.\n\n```typescript\nclass Bar {\n  public init(): void {\n    // ...\n  }\n}\n\ncontainer.afterResolution(\n  Bar,\n  // Callback signature is (token: InjectionToken<T>, result: T | T[], resolutionType: ResolutionType)\n  (_t, result) => {\n    result.init();\n  },\n  {frequency: \"Once\"}\n);\n```\n\n### Child Containers\n\nIf you need to have multiple containers that have disparate sets of registrations, you can create child containers:\n\n```typescript\nconst childContainer1 = container.createChildContainer();\nconst childContainer2 = container.createChildContainer();\nconst grandChildContainer = childContainer1.createChildContainer();\n```\n\nEach of the child containers will have independent registrations, but if a registration is absent in the child container at resolution, the token will be resolved from the parent. This allows for a set of common services to be registered at the root, with specialized services registered on the child. This can be useful, for example, if you wish to create per-request containers that use common stateless services from the root container.\n\n### Clearing Instances\n\nThe `container.clearInstances()` method allows you to clear all previously created and registered instances:\n\n```typescript\nclass Foo {}\n@singleton()\nclass Bar {}\n\nconst myFoo = new Foo();\ncontainer.registerInstance(\"Test\", myFoo);\nconst myBar = container.resolve(Bar);\n\ncontainer.clearInstances();\n\ncontainer.resolve(\"Test\"); // throws error\nconst myBar2 = container.resolve(Bar); // myBar !== myBar2\nconst myBar3 = container.resolve(Bar); // myBar2 === myBar3\n```\n\nUnlike with `container.reset()`, the registrations themselves are not cleared.\nThis is especially useful for testing:\n\n```typescript\n@singleton()\nclass Foo {}\n\nbeforeEach(() => {\n  container.clearInstances();\n});\n\ntest(\"something\", () => {\n  container.resolve(Foo); // will be a new singleton instance in every test\n});\n```\n\n# Circular dependencies\n\nSometimes you need to inject services that have cyclic dependencies between them. As an example:\n\n```typescript\n@injectable()\nexport class Foo {\n  constructor(public bar: Bar) {}\n}\n\n@injectable()\nexport class Bar {\n  constructor(public foo: Foo) {}\n}\n```\n\nTrying to resolve one of the services will end in an error because always one of the constructor will not be fully defined to construct the other one.\n\n```typescript\ncontainer.resolve(Foo);\n```\n\n```\nError: Cannot inject the dependency at position #0 of \"Foo\" constructor. Reason:\n    Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.\n```\n\n### The `delay` helper function\n\nThe best way to deal with this situation is to do some kind of refactor to avoid the cyclic dependencies. Usually this implies introducing additional services to cut the cycles.\n\nBut when refactor is not an option you can use the `delay` function helper. The `delay` function wraps the constructor in an instance of `DelayedConstructor`.\n\nThe _delayed constructor_ is a kind of special `InjectionToken` that will eventually be evaluated to construct an intermediate proxy object wrapping a factory for the real object.\n\nWhen the proxy object is used for the first time it will construct a real object using this factory and any usage will be forwarded to the real object.\n\n```typescript\n@injectable()\nexport class Foo {\n  constructor(@inject(delay(() => Bar)) public bar: Bar) {}\n}\n\n@injectable()\nexport class Bar {\n  constructor(@inject(delay(() => Foo)) public foo: Foo) {}\n}\n\n// construction of foo is possible\nconst foo = container.resolve(Foo);\n\n// property bar will hold a proxy that looks and acts as a real Bar instance.\nfoo.bar instanceof Bar; // true\n```\n\n### Interfaces and circular dependencies\n\nWe can rest in the fact that a `DelayedConstructor` could be used in the same contexts that a constructor and will be handled transparently by tsyringe. Such idea is used in the next example involving interfaces:\n\n```typescript\nexport interface IFoo {}\n\n@injectable()\n@registry([\n  {\n    token: \"IBar\",\n    // `DelayedConstructor` of Bar will be the token\n    useToken: delay(() => Bar)\n  }\n])\nexport class Foo implements IFoo {\n  constructor(@inject(\"IBar\") public bar: IBar) {}\n}\nexport interface IBar {}\n\n@injectable()\n@registry([\n  {\n    token: \"IFoo\",\n    useToken: delay(() => Foo)\n  }\n])\nexport class Bar implements IBar {\n  constructor(@inject(\"IFoo\") public foo: IFoo) {}\n}\n```\n\n# Disposable instances\nAll instances created by the container that implement the [`Disposable`](./src/types/disposable.ts)\ninterface will automatically be disposed of when the container is disposed.\n\n```typescript\ncontainer.dispose();\n```\n\nor to await all asynchronous disposals:\n\n```typescript\nawait container.dispose();\n```\n\n# Full examples\n\n## Example without interfaces\n\nSince classes have type information at runtime, we can resolve them without any\nextra information.\n\n```typescript\n// Foo.ts\nexport class Foo {}\n```\n\n```typescript\n// Bar.ts\nimport {Foo} from \"./Foo\";\nimport {injectable} from \"tsyringe\";\n\n@injectable()\nexport class Bar {\n  constructor(public myFoo: Foo) {}\n}\n```\n\n```typescript\n// main.ts\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Bar} from \"./Bar\";\n\nconst myBar = container.resolve(Bar);\n// myBar.myFoo => An instance of Foo\n```\n\n## Example with interfaces\n\nInterfaces don't have type information at runtime, so we need to decorate them\nwith `@inject(...)` so the container knows how to resolve them.\n\n```typescript\n// SuperService.ts\nexport interface SuperService {\n  // ...\n}\n```\n\n```typescript\n// TestService.ts\nimport {SuperService} from \"./SuperService\";\nexport class TestService implements SuperService {\n  //...\n}\n```\n\n```typescript\n// Client.ts\nimport {injectable, inject} from \"tsyringe\";\n\n@injectable()\nexport class Client {\n  constructor(@inject(\"SuperService\") private service: SuperService) {}\n}\n```\n\n```typescript\n// main.ts\nimport \"reflect-metadata\";\nimport {Client} from \"./Client\";\nimport {TestService} from \"./TestService\";\nimport {container} from \"tsyringe\";\n\ncontainer.register(\"SuperService\", {\n  useClass: TestService\n});\n\nconst client = container.resolve(Client);\n// client's dependencies will have been resolved\n```\n\n## Injecting primitive values (Named injection)\n\nPrimitive values can also be injected by utilizing named injection\n\n```typescript\nimport {singleton, inject} from \"tsyringe\";\n\n@singleton()\nclass Foo {\n  private str: string;\n  constructor(@inject(\"SpecialString\") value: string) {\n    this.str = value;\n  }\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst str = \"test\";\ncontainer.register(\"SpecialString\", {useValue: str});\n\nconst instance = container.resolve(Foo);\n```\n\n# Non goals\n\nThe following is a list of features we explicitly plan on not adding:\n\n- Property Injection\n\n# How to release\nThe library uses the step action `EndBug/version-check` which requires these two conditions to be met to execute:\n\n1. Have a commit named: `Release X.Y.Z`\n2. In the commit, have a version change in the `package.json` file.\n\n# Contributing\n\nThis project welcomes contributions and suggestions. Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit [https://cla.microsoft.com](https://cla.microsoft.com).\n\nWhen you submit a pull request, a CLA-bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\nFor more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or\ncontact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n",
    "licenseText": "    MIT License\n\n    Copyright (c) Microsoft Corporation. All rights reserved.\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/tsyringe/-/tsyringe-4.10.0.tgz#d0c95815d584464214060285eaaadd94aa03299c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/tsyringe/-/tsyringe-4.10.0.tgz",
    "hash": "d0c95815d584464214060285eaaadd94aa03299c",
    "integrity": "sha512-axr3IdNuVIxnaK5XGEUFTu3YmAQ6lllgrvqfEoR16g/HGnYY/6We4oWENtAnzK6/LpJ2ur9PAb80RBt7/U4ugw==",
    "registry": "npm",
    "packageName": "tsyringe",
    "cacheIntegrity": "sha512-axr3IdNuVIxnaK5XGEUFTu3YmAQ6lllgrvqfEoR16g/HGnYY/6We4oWENtAnzK6/LpJ2ur9PAb80RBt7/U4ugw== sha1-0MlYFdWERkIUBgKF6qrdlKoDKZw="
  },
  "registry": "npm",
  "hash": "d0c95815d584464214060285eaaadd94aa03299c"
}